{"type": "root", "attrs": {"index": "no"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Cryptomatte"], "extent": [0, 16]}, {"type": "summary", "indent": 0, "text": ["How to generate image maps associating each pixel in the image with the object name and/or material in the original source scene."], "extent": [29, 167]}, {"level": 2, "id": "oview", "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [155, 178], "body": [{"type": "para", "indent": 0, "text": ["Cryptomatte is ", {"scheme": null, "value": "https://github.com/Psyop/Cryptomatte", "type": "link", "text": ["a set of open-source tools"], "exists": true}, " for generating and working with images that associate individual pixels with object IDs. More generally, a ", {"type": "q", "text": ["cryptomatte"]}, " is the type of image generated by the tools, or equivalent features in other software such as Houdini. This is a deep EXR image which stores object names/materials per-pixel, with special filtering to properly support anti-aliasing and transparency."], "extent": [178, 632]}, {"type": "para", "indent": 0, "text": ["You can use the image to mask compositing effects to only the pixels associated with certain 3D source objects, or certain materials, without having to re-render the scene."], "extent": [632, 806]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/render/cryptomatte_example.jpg", "type": "img", "text": ""}], "extent": [806, 854]}, {"type": "para", "indent": 0, "text": ["The following example shows how you can use a cryptomatte image to isolate a specific material in a Houdini compositor network."], "extent": [854, 983]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/render/crypto_example.jpg", "type": "img", "text": ""}], "extent": [983, 1026]}, {"type": "para", "indent": 0, "text": ["See Cryptomatte\u2019s ", {"scheme": null, "value": "https://github.com/Psyop/Cryptomatte", "type": "link", "text": ["official site"], "exists": true}, " for specifications and plugins for popular compositing applications."], "extent": [1026, 1167]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [1167, 1173], "body": [{"type": "para", "indent": 4, "text": ["Cryptomatte is supported by Karma CPU and Karma XPU."], "extent": [1173, 1231]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Tips and notes"], "extent": [206, 227], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Cryptomatte uses the primary plane\u2019s ", {"scheme": null, "value": "/props/mantra#vm_pfilter", "type": "link", "text": ["pixel filter"], "fullpath": "/props/mantra.html#vm_pfilter", "fragment": "#vm_pfilter"}, ".\n  Custom pixel filter plugins can be used as well, but a filter that reads data\n  from additional image planes (for example, ", {"type": "code", "text": ["minmax"]}, " filter reads data from\n  ", {"type": "code", "text": ["Z"]}, " plane) are not allowed."], "extent": [227, 496]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You cannot generate cryptomatte in micropolygon rendering mode."], "extent": [496, 563]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Keep in mind that opacity and transparency are two separate things: \n  Partially opaque materials let camera rays through, while transparent\n  materials obstruct camera rays and cast secondary (refraction) rays. The\n  pixel coverage is computed based on opacity, so you won\u2019t be able to generate\n  matte for objects behind refractive materials."], "extent": [563, 912]}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["How to"], "extent": [912, 925], "body": [{"type": "task_group", "body": [{"ext": null, "type": "task", "indent": 0, "text": [" Render a USD scene to a cryptomatte image using Karma"], "role": "item", "extent": [925, 989], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "/solaris/cryptomatte", "type": "link", "text": ["Cryptomatte in Karma"], "fullpath": "/solaris/cryptomatte.html"}, "."], "extent": [989, 1043]}], "container": true}, {"ext": null, "type": "task", "indent": 0, "text": [" Render a traditional Houdini object-level scene to a cryptomatte using Mantra"], "role": "item", "extent": [1043, 1130], "body": [{"type": "para", "indent": 4, "text": ["The Mantra ROP lets you generate a cryptomatte image as an AOV plane in the main rendered image, or in an extra generated file."], "extent": [1130, 1263]}, {"type": "ord_group", "body": [{"blevel": 6, "type": "ord", "indent": 4, "text": ["Set up the Mantra ROP you want to use to render the scene."], "extent": [1263, 1329]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["Click the ", {"type": "ui", "text": ["Images"]}, " tab and then the ", {"type": "ui", "text": ["Cryptomatte"]}, " sub-tab."], "extent": [1329, 1399]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["Click the Plus button to add a layer."], "extent": [1399, 1444]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["Use the ", {"type": "ui", "text": ["Property"]}, " field to choose how to generate cryptomatte IDs."], "extent": [1444, 1521], "body": [{"type": "para", "indent": 8, "text": ["Use the drop-down menu after the text field to generate IDs by object name or material name."], "extent": [1521, 1623]}, {"type": "para", "indent": 8, "text": [{"type": "em", "text": ["or"]}], "extent": [1623, 1637]}, {"type": "para", "indent": 8, "text": ["You can enter the name of a user-created string property you have added to objects or materials using a ", {"type": "code", "text": ["Properties"]}, " node. See ", {"scheme": null, "value": "/props/", "type": "link", "text": ["render properties"], "fullpath": "/props/index.html"}, " for detailed information on how to add user properties to objects or materials."], "extent": [1637, 1881]}], "container": true}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["By default, the cryptmatte layer is generated as an image plane in the main rendered image. To render it to a separate file, turn on ", {"type": "ui", "text": ["Different file"]}, " and set it to the output path of the ", {"type": "code", "text": [".exr"]}, " file to generate. "], "extent": [1881, 2103]}], "container": true}], "container": true}, {"ext": null, "type": "task", "indent": 0, "text": [" Generate masks in the compositor from a cryptomatte"], "role": "item", "extent": [2103, 2164], "body": [{"type": "para", "indent": 4, "text": ["See the help for the ", {"scheme": null, "value": "/nodes/cop2/cryptomatte", "type": "link", "text": ["Cryptomatte COP"], "fullpath": "/nodes/cop2/cryptomatte.html"}, "."], "extent": [2164, 2234]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Instancing and unique IDs"], "extent": [2234, 2266], "body": [{"type": "para", "indent": 0, "text": ["In order to matte a particular instance among other instances, you need to generate Cryptomatte using a user string property whose value is unique to each instance."], "extent": [2266, 2433]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/render/crypto_inst.jpg", "type": "img", "text": ""}], "extent": [2433, 2473]}, {"type": "para", "indent": 0, "text": ["Here\u2019s an example method using Material Stylesheets:"], "extent": [2473, 2527]}, {"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["Set up ", {"scheme": null, "value": "/nodes/obj/instance", "type": "link", "text": ["instancing"], "fullpath": "/nodes/obj/instance.html"}, "."], "extent": [2527, 2571]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Make sure you're using ", {"type": "ui", "text": ["fast point instancing"]}, "."], "extent": [2571, 2624]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Using ", {"scheme": null, "value": "/nodes/sop/attribexpression", "type": "link", "text": ["Attribute Expression"], "fullpath": "/nodes/sop/attribexpression.html"}, " (or any method you prefer), give each point inside ", {"type": "code", "text": ["Instance"]}, " node a unique integer."], "extent": [2624, 2769]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Add a user string property to the ", {"type": "code", "text": ["Instance"]}, " node."], "extent": [2769, 2823]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Add a root level stylesheet, target ", {"type": "ui", "text": ["Point Instances"]}, ", override script ", {"type": "ui", "text": ["Render Property"]}, " using ", {"type": "ui", "text": ["Inline Script"]}, ", and set up appropriate bindings:"], "extent": [2823, 2976], "body": [{"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/crypto_mss.jpg", "type": "img", "text": ""}], "extent": [2976, 3019]}, {"type": "para", "indent": 4, "text": ["Example inline script:"], "extent": [3019, 3046]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    cvex myFn(int id=0; export string myuserprop=\"\") \n    { \n        myuserprop = sprintf(\"foo%d\", id);\n    }\n    "], "extent": [3046, 3182]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["In this example, the name of the user property is ", {"type": "code", "text": ["myuserprop"]}, ". The name of the\npoint integer attribute is ", {"type": "code", "text": ["mypointid"]}, ". The unique property values that are\ngenerated are ", {"type": "code", "text": ["foo0"]}, ", ", {"type": "code", "text": ["foo1"]}, ", ", {"type": "code", "text": ["foo2"]}, " etc (the # comes from ", {"type": "code", "text": ["mypointid"]}, " attribute)."], "extent": [3182, 3423]}, {"type": "para", "indent": 0, "text": ["Note that, in this example, ", {"type": "ui", "text": ["Inline Script"]}, " was only necessary to convert\ninteger attribute to string property. If you're using a string attribute then\nyou could simply use ", {"type": "ui", "text": ["Attribute Binding"]}, " and skip the script and data binding\naltogether."], "extent": [3423, 3670]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/shade/stylesheets", "type": "link", "text": ["Material Stylesheets"], "fullpath": "/shade/stylesheets.html"}, " for more information on how to\nuse stylesheets."], "extent": [3670, 3764]}]}], "title": ["Cryptomatte"], "summary": ["How to generate image maps associating each pixel in the image with the object name and/or material in the original source scene."], "included": ["/solaris/cryptomatte"]}