{"type": "root", "attrs": {}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Writing out USD"], "extent": [0, 20]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [20, 37], "body": [{"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "usd", "type": "link", "text": ["USD basics"], "fullpath": "/solaris/usd.html"}, " and ", {"scheme": null, "value": "about_lops", "type": "link", "text": ["About LOP node"], "fullpath": "/solaris/about_lops.html"}, " for background information on USD and how LOP nodes generate USD layers."], "extent": [37, 165]}, {"type": "para", "indent": 0, "text": ["A LOP network generates a USD stage, either from scratch or starting with a top-level USD file, possibly adding in USD layers from files. At the end of the network, you can write out the finished USD, which will often involve writing out multiple files: a top-level file and separate files for each layer."], "extent": [165, 472]}, {"type": "para", "indent": 0, "text": ["Layers being read from disk are always left unmodified by the save process, though an anonymous layer generated by LOP nodes may overwrite an existing layer file on disk."], "extent": [472, 645]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["How to"], "extent": [645, 658], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["The main node that writes out the USD is the ", {"scheme": "Node", "value": "/nodes/out/usd", "type": "link", "text": ["USD node"], "fullpath": "/nodes/out/usd.html"}, ". This node is available as a LOP (which you can put at the end of the LOP network) or a ROP (which you can put in a render network and point at the LOP network you want to output)."], "extent": [658, 912], "body": [{"type": "para", "indent": 4, "text": ["(See ", {"scheme": null, "value": "#other", "type": "link", "text": ["other ways to write out USD"], "fullpath": "/solaris/output.html#other", "fragment": "#other"}, " below for more specialized options.)"], "extent": [912, 996]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["To create a USDZ file, you can use the ", {"scheme": "Node", "value": "/nodes/out/usdzip", "type": "link", "text": ["USD Zip node"], "fullpath": "/nodes/out/usdzip.html"}, " which creates a single self-contained USDZ file from an existing set of USD files on disk. This file is an archive containing all the layer files and textures used by those layer files. This is very useful for publishing final USD products on the Internet, but there are limitations to this file format that make it inappropriate for most uses in a pipeline. It is harder to modify (it must be extracted into individual files, modified, then repackaged), and does not support volume files inside the USDZ archive."], "extent": [996, 1584]}], "container": true}]}, {"level": 2, "id": "filepaths", "container": true, "type": "h", "indent": 0, "text": ["Where the files go"], "extent": [1584, 1621], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["In the ", {"scheme": "Node", "value": "/nodes/out/usd", "type": "link", "text": ["USD node"], "fullpath": "/nodes/out/usd.html"}, ", you specify a file path (in the ", {"type": "ui", "text": ["Output file"]}, " parameter) for the ", {"type": "q", "text": ["top-level"]}, " USD file, containing data from the root layer."], "extent": [1621, 1783], "body": [{"type": "para", "indent": 4, "text": ["In addition to this file, the node writes any layers that have their save path metadata set to their own USD files."], "extent": [1783, 1904]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use the ", {"scheme": "Node", "value": "/nodes/lop/configurelayer", "type": "link", "text": ["Configure Layer LOP"], "fullpath": "/nodes/lop/configurelayer.html"}, " to assign/change a save path for any layer in the network. When you render to USD the layer will be written out to disk."], "extent": [1904, 2090]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"scheme": "Node", "value": "/nodes/lop/sopimport", "type": "link", "text": ["SOP Import LOP"], "fullpath": "/nodes/lop/sopimport.html"}, " and ", {"scheme": "Node", "value": "/nodes/lop/sopcreate", "type": "link", "text": ["SOP Create LOP"], "fullpath": "/nodes/lop/sopcreate.html"}, " also let you specify a save path where the geometry will be written when you write out USD."], "extent": [2090, 2265]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Save paths should be specified as absolute paths, often using global variables such as HIP (", {"type": "code", "text": ["$HIP/props/lamp.usd"]}, "). During the save process, the ", {"scheme": "Node", "value": "/nodes/out/usd", "type": "link", "text": ["USD node"], "fullpath": "/nodes/out/usd.html"}, " by default will use an ", {"scheme": null, "value": "#processor", "type": "link", "text": ["output processor"], "fullpath": "/solaris/output.html#processor", "fragment": "#processor"}, " that translates these absolute paths to relative references between the layer files, which makes it easy to move all the layer files from one location to another."], "extent": [2265, 2653]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Flush Data After Each Frame"]}, " parameter on the render node controls whether it writes out data to disk after calculating each frame. This option can be used to generate a sequence of USD files each containing a single time sample (for example, ", {"type": "code", "text": ["lamp_0001.usd"]}, ", ", {"type": "code", "text": ["lamp_0002.usd"]}, ", and so on), or single files containing time sample data from all frames, depending on whether the output file name or save paths contain a time-varying component (such as ", {"type": "code", "text": ["$F"]}, ")."], "extent": [2653, 3119]}], "container": true}]}, {"level": 2, "id": "processors", "container": true, "type": "h", "indent": 0, "text": ["Output processors"], "extent": [3119, 3156], "body": [{"type": "para", "indent": 0, "text": ["Output processors are Python plugins that can alter the file locations and file path strings used for referencing external files. They also allow for arbitrary last minute edits to each layer file being saved."], "extent": [3156, 3368]}, {"type": "para", "indent": 0, "text": ["The USD node starts with one default output processor that makes file path references in layer files relative."], "extent": [3368, 3481]}, {"level": 3, "id": "custom_proc", "container": true, "type": "h", "indent": 0, "text": ["Writing a custom output processor"], "extent": [3481, 3537], "body": [{"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["Create a new directory ", {"type": "code", "text": ["$HOUDINI_USER_PREFS_DIR/husdplugins/outputprocessors"]}, "."], "extent": [3537, 3620], "body": [{"type": "para", "indent": 4, "text": ["(We\u2019ll create the plugin in the user prefs directory in this example. Of course, if you could put the ", {"type": "code", "text": ["husdplugins/outputprocessors"]}, " directory under any directory on the Houdini path.)"], "extent": [3620, 3810]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Inside ", {"type": "code", "text": ["$HOUDINI_USER_PREFS_DIR/husdplugins/outputprocessors"]}, ". create a Python file for your output processor plug-in. For example:"], "extent": [3810, 3945], "body": [{"lang": null, "type": "pre", "indent": 4, "text": ["\n    $HOUDINI_USER_PREFS_DIR/husdplugins/outputprocessors/outputreview.py\n    "], "extent": [3945, 4034]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["In the Python plug-in file, sublcass the ", {"type": "code", "text": ["husd.outputprocessor.OutputProcessor"]}, " class."], "extent": [4034, 4125], "body": [{"type": "para", "indent": 4, "text": ["In the subclass, implement the ", {"type": "code", "text": ["name()"]}, " static method to return a unique name, and ", {"type": "code", "text": ["displayName()"]}, " static method to return a string describing what the processor does (for example, ", {"type": "code", "text": ["Save Paths Relative to Output Path"]}, ")."], "extent": [4125, 4350]}, {"lang": "python", "type": "pre", "indent": 4, "text": ["\n    import hou\n    from husd.outputprocessor import OutputProcessor\n\n\n    class ReviewOutputProcessor(OutputProcessor):\n        @staticmethod\n        def name():\n            return \"review\"\n        @staticmethod\n        def displayName():\n            return \"Manually Review Every Output Path\"\n    "], "extent": [4350, 4673]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["At the bottom of the file, define a function called ", {"type": "code", "text": ["usdOutputProcessor()"]}, " that takes no arguments and returns your class whenever it\u2019s called."], "extent": [4673, 4821], "body": [{"type": "para", "indent": 4, "text": ["The existence of this function is what marks this module as implementing an output processor (Houdini looks for modules containing this function), and how Houdini creates instances of your output processor object. Each time a USD save operation is started, a new instance of your output processor is created. This instance is used for the duration of that save operation."], "extent": [4821, 5198]}, {"lang": "python", "type": "pre", "indent": 4, "text": ["\n    import hou\n    from husd.outputprocessor import OutputProcessor\n\n\n    class ReviewOutputProcessor(OutputProcessor):\n        @staticmethod\n        def name():\n            return __class__.__name__\n        @staticmethod\n        def displayName():\n            return \"Display the list of output files\"\n\n\n    # Must have: module-level function to return a processor instance\n    outputprocessor = ReviewOutputProcessor()\n    def usdOutputProcessor():\n        return outputprocessor\n    "], "extent": [5198, 5709]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Override ", {"scheme": null, "value": "#processor_api", "type": "link", "text": ["API methods"], "fullpath": "/solaris/output.html#processor_api", "fragment": "#processor_api"}, " to implement your output processor. See the ", {"scheme": null, "value": "#processor_api", "type": "link", "text": ["output processor API"], "fullpath": "/solaris/output.html#processor_api", "fragment": "#processor_api"}, " below."], "extent": [5709, 5840], "body": [{"lang": "python", "type": "pre", "indent": 4, "text": ["\n    import hou\n    from husd.outputprocessor import OutputProcessor\n\n\n    class ReviewOutputProcessor(OutputProcessor):\n        @staticmethod\n        def name():\n            return \"displayoutputfiles\"\n        @staticmethod\n        def displayName():\n            return \"Display the list of output files\"\n\n        def processSavePath(self, asset_path, referencing_layer_path, asset_is_layer):\n            # Make the asset path absolute\n            asset_path = hou.text.abspath(asset_path)\n\n            # This processor asks the user to manually rewrite every file path.\n            # This is just an example, don't do this! It would be annoying!\n            return hou.ui.readInput(\n                message=\"Rewrite this output file path if you want\",\n                initial_contents=asset_path,\n                buttons=(\"OK\",),\n            )\n\n        def processReferencePath(self, asset_path, referencing_layer_path, asset_is_layer):\n            # Make file path pointers relative to the source file's location\n            return hou.text.relpath(asset_path, referencing_layer_path)\n\n        def processReferenceExpression(self, asset_expression, referencing_layer_path, asset_is_layer):\n            # Leave stage variable expressions unchanged\n            return asset_expression\n\n\n    # Must have: module-level function to return the processor class\n    def usdOutputProcessor():\n        return ReviewOutputProcessor\n    "], "extent": [5840, 7292]}], "container": true}], "container": true}]}, {"level": 3, "id": "processor_api", "container": true, "type": "h", "indent": 0, "text": ["Output Processor method API"], "extent": [7292, 7346], "body": [{"type": "box_group", "body": [{"ext": null, "type": "box", "indent": 0, "role": "item", "extent": [7346, 7353], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["@staticmethod hidden()"]}, "  \u2192 ", {"type": "code", "text": ["bool"]}], "extent": [7383, 7423], "body": [{"type": "para", "indent": 8, "text": ["If this method returns ", {"type": "code", "text": ["True"]}, ", this processor is not included in the list of output processors shown to the user. The default implementation returns ", {"type": "code", "text": ["False"]}, "."], "extent": [7423, 7590]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["@staticmethod name()"]}, "  \u2192 ", {"type": "code", "text": ["str"]}, " (REQUIRED)"], "extent": [7590, 7638], "body": [{"type": "para", "indent": 8, "text": ["Returns a unique name for the processor."], "extent": [7638, 7688]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [7688, 7702], "body": [{"type": "para", "indent": 12, "text": ["You must override this method in your subclass, otherwise it will raise a ", {"type": "code", "text": ["NotImplementedError"]}, " exception when Houdini tries to instantiate your class."], "extent": [7702, 7867]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["@staticmethod displayName()"]}, "  \u2192 ", {"type": "code", "text": ["str"]}, " (REQUIRED)"], "extent": [7867, 7922], "body": [{"type": "para", "indent": 8, "text": ["Returns a label to describe the processor, in the list of output processors shown to the user."], "extent": [7922, 8026]}, {"type": "para", "indent": 8, "text": ["The label should describe the function/of the processor, for example: ", {"type": "code", "text": ["Save Paths Relative to Output Path"]}, "."], "extent": [8026, 8143]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [8143, 8157], "body": [{"type": "para", "indent": 12, "text": ["You must override this method in your subclass, otherwise it will raise a ", {"type": "code", "text": ["NotImplementedError"]}, " exception when Houdini tries to instantiate your class."], "extent": [8157, 8322]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["@staticmethod parameters()"]}, "  \u2192 ", {"type": "code", "text": ["str"]}], "extent": [8322, 8365], "body": [{"type": "para", "indent": 8, "text": ["Returns a string containing Houdini ", {"type": "q", "text": ["dialog script"]}, " describing the parameters this processor shows to the user for configuration."], "extent": [8365, 8504]}, {"type": "para", "indent": 8, "text": ["The default implementation returns the script for an empty parameter group, so ", {"type": "strong", "text": ["if your processor doesn\u2019t need any parameters, you don\u2019t need to override this method"]}, "."], "extent": [8504, 8681]}, {"type": "para", "indent": 8, "text": ["You can generate the dialog script by building up a ", {"scheme": "Hom", "value": "/hom/hou/ParmTemplateGroup", "type": "link", "text": "", "fallback_text": "hou.ParmTemplateGroup", "fullpath": "/hom/hou/ParmTemplateGroup.html"}, "\n        with ", {"scheme": "Hom", "value": "/hom/hou/ParmTemplate", "type": "link", "text": "", "fallback_text": "hou.ParmTemplate", "fullpath": "/hom/hou/ParmTemplate.html"}, " objects inside, and then returning the value\n        from ", {"scheme": "Hom", "value": "/hom/hou/ParmTemplateGroup#asDialogScript", "type": "link", "text": "", "fallback_text": "hou.ParmTemplateGroup.asDialogScript", "fullpath": "/hom/hou/ParmTemplateGroup.html#asDialogScript", "fragment": "#asDialogScript"}, "."], "extent": [8681, 8908]}, {"lang": "python", "type": "pre", "indent": 8, "text": ["\n        group = hou.ParmTemplateGroup()\n        group.append(hou.StringParmTemplate(\n            \"texturedir\",\n            \"Texture Directory\",\n            string_type=hou.stringParmType.FileReference\n        ))\n        return group.asDialogScript()\n        "], "extent": [8908, 9199]}, {"type": "para", "indent": 8, "text": ["The internal names of any parameters you create here must be unique\n        among all other parameters on the render node, so you probably want to\n        use a naming scheme like ", {"type": "code", "text": [{"type": "var", "text": ["modulename"]}, "_", {"type": "var", "text": ["parmname"]}]}, " (where ", {"type": "var", "text": ["modulename"]}, " is the name of the Python module under ", {"type": "code", "text": ["husdplugins/outputprocessors"]}, ")."], "extent": [9199, 9513]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["stageVariables(self)"]}, "  \u2192 ", {"type": "code", "text": ["dict"]}], "extent": [9513, 9551], "body": [{"type": "para", "indent": 8, "text": ["This method should return the stage variables that are set on the stage being saved. The default implementation returns the ", {"type": "code", "text": ["stage_variables"]}, " dictionary passed to the base class implementation of the ", {"type": "code", "text": ["beginSave"]}, " method."], "extent": [9551, 9780]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["beginSave(self, config_node, config_overrides, lop_node, t, stage_variables)"]}], "extent": [9780, 9864], "body": [{"type": "para", "indent": 8, "text": ["Called when a render node using this processor starts to write out files. This gives you the chance to read parameter values (either the configuration parameters added by parameters(), or the render node\u2019s own parameters, depending on what information you need). You should always call the base class implementation of this method, which will store the ", {"type": "code", "text": ["config_node"]}, ", ", {"type": "code", "text": ["lop_node"]}, ", and ", {"type": "code", "text": ["t"]}, " parameters into ", {"type": "code", "text": ["self.config_node"]}, ", ", {"type": "code", "text": ["self.lop_node"]}, ", and ", {"type": "code", "text": ["self.t"]}, " respectively for use in the processing methods."], "extent": [9864, 10375]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["config_node"]}], "extent": [10375, 10398], "body": [{"type": "para", "indent": 12, "text": ["A ", {"scheme": "Hom", "value": "/hom/hou/Node", "type": "link", "text": "", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node.html"}, " object representing the render node."], "extent": [10398, 10465]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["config_overrides"]}], "extent": [10465, 10493], "body": [{"type": "para", "indent": 12, "text": ["A ", {"type": "code", "text": ["dict"]}, " of values that should be used to override whatever may be set on the node. The ", {"type": "code", "text": ["OutputProcessor.evalConfig"]}, " method can be used to query a configuration value, accepting the override value from this dictionary if available, otherwise falling back to evaluating the matching parameter on the ", {"type": "code", "text": ["config_node"]}, "."], "extent": [10493, 10820]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["lop_node"]}], "extent": [10820, 10840], "body": [{"type": "para", "indent": 12, "text": ["A ", {"scheme": "Hom", "value": "/hom/hou/LopNode", "type": "link", "text": "", "fallback_text": "hou.LopNode", "fullpath": "/hom/hou/LopNode.html"}, " object representing the LOP node that generated the stage being saved."], "extent": [10840, 10944]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["t"]}], "extent": [10944, 10957], "body": [{"type": "para", "indent": 12, "text": ["A floating point value representing the time (in seconds) along the timeline which the node is rendering. If you read parameter values from the node, you should use ", {"type": "code", "text": ["Parm.evalAtTime(t)"]}, " in case the parameter is animated."], "extent": [10957, 11191]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["stage_variables"]}], "extent": [11191, 11218], "body": [{"type": "para", "indent": 12, "text": ["A dictionary containing the stage variables set on the root layer of the stage being written to disk. This parameter should be passed to the base class implementation of this method so this dictionary can be accessed from the ", {"type": "code", "text": ["processReferencePath"]}, " and ", {"type": "code", "text": ["processReferenceExpression"]}, " methods through the ", {"type": "code", "text": ["stageVariables"]}, " method."], "extent": [11218, 11558]}], "container": true}], "container": true}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["processSavePath(self, asset_path, referencing_layer_path, asset_is_layer)"]}, "  \u2192 ", {"type": "code", "text": ["str"]}], "extent": [11558, 11648], "body": [{"type": "para", "indent": 8, "text": ["Called when the render node needs to determine where on disk to save an asset. The ", {"type": "code", "text": ["asset_path"]}, " is the file path as Houdini knows it (for example, from USD metadata or a Houdini parameter)."], "extent": [11648, 11847]}, {"type": "para", "indent": 8, "text": ["This should return an absolute path to where the asset should be saved.\n        (If you return a relative path from this method, it will be relative to the current directory (", {"type": "code", "text": ["os.getcwd()"]}, ") which is probably not what you want.)"], "extent": [11847, 12084]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_path"]}], "extent": [12084, 12106], "body": [{"type": "para", "indent": 12, "text": ["The path to the asset, as specified in Houdini. This string comes with expressions and environment variables (such as ", {"type": "code", "text": ["$HIP"]}, ") expanded already, so if you want to compare to another path, you should also expand that path (for example, with ", {"type": "code", "text": ["os.path.expandvars()"]}, " or ", {"type": "code", "text": ["hou.text.expandString()"]}, ")."], "extent": [12106, 12412]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["referencing_layer_path"]}], "extent": [12412, 12446], "body": [{"type": "para", "indent": 12, "text": ["The processed save path of the layer file that is referencing this asset. This parameter allows assets to be saved in specific locations relative to the layer that brings them into the scene. This can be particularly useful for non-layer files that may get written out during the save process, such as volume files."], "extent": [12446, 12775]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_is_layer"]}], "extent": [12775, 12801], "body": [{"type": "para", "indent": 12, "text": ["A boolean value indicating whether this asset is a USD layer file. If this is ", {"type": "code", "text": ["False"]}, ", the asset is something else (for example, a texture or volume file)."], "extent": [12801, 12970]}], "container": true}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [12970, 12984], "body": [{"type": "para", "indent": 12, "text": ["Only the first processor in line sees the ", {"type": "code", "text": ["asset_path"]}, " as it was originally in Houdini. For all other processors in line, they receive the absolute path the first call returned."], "extent": [12984, 13175]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["processReferencePath(self, asset_path, referencing_layer_path, asset_is_layer)"]}, "  \u2192 ", {"type": "code", "text": ["str"]}], "extent": [13175, 13270], "body": [{"type": "para", "indent": 8, "text": ["Called when the render node needs to write a file path pointing to an asset (to sublayer or reference in the file)."], "extent": [13270, 13395]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_path"]}], "extent": [13395, 13417], "body": [{"type": "para", "indent": 12, "text": ["The path to the asset. If the asset is being created as part of the USD save process, this will be the final save path for the asset after running all output processors. This value will always be a full path."], "extent": [13417, 13647]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["referencing_layer_path"]}], "extent": [13647, 13681], "body": [{"type": "para", "indent": 12, "text": ["The processed, absolute save location of the layer file containing the reference to the asset. You can use this to make the path pointer relative. (For example, ", {"type": "code", "text": ["hou.text.relpath(asset_saved_path, referencing_layer_path)"]}, ")."], "extent": [13681, 13926]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_is_layer"]}], "extent": [13926, 13952], "body": [{"type": "para", "indent": 12, "text": ["A boolean value indicating whether this asset is a USD layer file. If this is ", {"type": "code", "text": ["False"]}, ", the asset is something else (for example, a texture or volume file)."], "extent": [13952, 14121]}], "container": true}], "container": true}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["processReferenceExpression(self, asset_path, referencing_layer_path, asset_is_layer)"]}, "  \u2192 ", {"type": "code", "text": ["str"]}], "extent": [14121, 14222], "body": [{"type": "para", "indent": 8, "text": ["Called when the render node needs to write a file path pointing to an asset (to sublayer or reference in the file)."], "extent": [14222, 14347]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_path"]}], "extent": [14347, 14369], "body": [{"type": "para", "indent": 12, "text": ["The path to the asset. If the asset is being created as part of the USD save process, this will be the final save path for the asset after running all output processors. This value will always be a full path."], "extent": [14369, 14591]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["referencing_layer_path"]}], "extent": [14591, 14625], "body": [{"type": "para", "indent": 12, "text": ["The processed, absolute save location of the layer file containing the reference to the asset. You can use this to make the path pointer relative. (For example, ", {"type": "code", "text": ["hou.text.relpath(asset_saved_path, referencing_layer_path)"]}, ")."], "extent": [14625, 14862]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_is_layer"]}], "extent": [14862, 14888], "body": [{"type": "para", "indent": 12, "text": ["A boolean value indicating whether this asset is a USD layer file. If this is ", {"type": "code", "text": ["False"]}, ", the asset is something else (for example, a texture or volume file)."], "extent": [14888, 15057]}], "container": true}], "container": true}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["processLayer(self, layer)"]}], "extent": [15057, 15090], "body": [{"type": "para", "indent": 8, "text": ["Called immediately prior to writing a layer file to disk. The ", {"type": "code", "text": ["layer"]}, " parameter is a ", {"type": "code", "text": ["pxr.Sdf.Layer"]}, " object which is editable, and can be modified in any way. The default implementation does not modify the layer."], "extent": [15090, 15312]}, {"type": "para", "indent": 8, "text": ["Return ", {"type": "code", "text": ["True"]}, " if this method modifies the layer, otherwise return ", {"type": "code", "text": ["False"]}, "."], "extent": [15312, 15397]}], "container": true}], "container": true}], "container": true, "attrs": {"display": "rounded silver"}}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "proc_scripting", "container": true, "type": "h", "indent": 0, "text": ["Adding an output processor in a script"], "extent": [15397, 15461], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Houdini will use an output processor on a ", {"scheme": "Node", "value": "/nodes/out/usd", "type": "link", "text": ["USD node"], "fullpath": "/nodes/out/usd.html"}, " if the node instance has a ", {"scheme": null, "value": "/network/spare", "type": "link", "text": ["spare checkbox parameter"], "fullpath": "/network/spare.html"}, " named ", {"type": "code", "text": ["enableoutputprocessor_", {"type": "var", "text": ["modulename"]}]}, " that is turned on (where ", {"type": "var", "text": ["modulename"]}, " is the name of the Python module under ", {"type": "code", "text": ["husdplugins/outputprocessors"]}, ")."], "extent": [15461, 15757], "body": [{"type": "para", "indent": 4, "text": ["For example, if you implemented your class in ", {"type": "code", "text": ["$HOUDINI_USER_PREFS_DIR/husdplugins/outputprocessors/myprocessor.py"]}, ", then you would need to have a spare checkbox parameter named ", {"type": "code", "text": ["enableoutputprocessor_myprocessor"]}, " on a node to activate the processor for that node."], "extent": [15757, 16027]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["This means you can enable a processor by creating the correct parameter and turning it on, such as in a script, even if the processor is hidden from the processor list in the user interface (see the ", {"type": "code", "text": ["hidden()"]}, " method above)."], "extent": [16027, 16255], "body": [{"type": "para", "indent": 4, "text": ["You can disable a processor by turning off the spare checkbox, or deleting the spare parameter."], "extent": [16255, 16356]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If the output processor has additional parameters for configuring it (see the ", {"type": "code", "text": ["parameters()"]}, " method above), you can create and fill in those parameters in a script as well."], "extent": [16356, 16533]}], "container": true}]}]}, {"level": 2, "id": "anim", "container": true, "type": "h", "indent": 0, "text": ["Saving animation"], "extent": [16533, 16563], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Flush Data After Each Frame"]}, " parameter on the USD render node controls whether it writes data out after each frame of data is generated. This feature can be used to create individual files containing the data for each frame, or arbitrarily large files containing time sample data across all frames."], "extent": [16563, 16871]}, {"type": "para", "indent": 0, "text": ["When the USD render node writes out a frame range with ", {"type": "ui", "text": ["Flush Data After Each Frame"]}, " off:"], "extent": [16871, 16964]}, {"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["For each frame the ROP will generate a set of layers ready to be saved to disk, but which still exist in-memory."], "extent": [16964, 17080]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["It uses ", {"scheme": "Node", "value": "/nodes/out/usdstitch", "type": "link", "text": ["USD Stitch"], "fullpath": "/nodes/out/usdstitch.html"}, " to combine the generated frames with previously cooked frames in-memory."], "extent": [17080, 17196]}], "container": true}, {"type": "para", "indent": 0, "text": ["If the LOP Network is generating a lot of data, this can quickly use a lot of memory (even though the stitch operation does not duplicate data which is the same from frame to frame)."], "extent": [17196, 17380]}, {"type": "para", "indent": 0, "text": ["If you find writing out animated USD runs out of memory in Houdini, you can enable this option to limit Houdini to only have a single frame\u2019s data in memory at any one time. The result may take longer to write to disk, and the final file size may be larger than with this option disabled. But the amount of data that can be written will not be limited by the computer\u2019s available memory."], "extent": [17380, 17769]}, {"type": "para", "indent": 0, "text": ["Another approach is to write out a sequence of USD files each containing a single time sample of data, then using the ", {"scheme": "Node", "value": "/nodes/out/usdstitchclips", "type": "link", "text": ["USD Stitch Clips ROP"], "fullpath": "/nodes/out/usdstitchclips.html"}, " to generate a USD value clip. This approach only works if there is an isolated branch in the scene graph tree where the large data set exists, and the data for this branch can be written to a separate USD file."], "extent": [17769, 18147]}]}, {"level": 2, "id": "other", "container": true, "type": "h", "indent": 0, "text": ["Other ways to write out USD"], "extent": [18147, 18189], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use Python (interactively in a Python shell or procedurally in a ", {"scheme": "Node", "value": "/nodes/lop/pythonscript", "type": "link", "text": ["Python Script LOP"], "fullpath": "/nodes/lop/pythonscript.html"}, ") to write out individual layers."], "extent": [18189, 18341]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can right-click a node, open the ", {"type": "ui", "text": ["LOP Actions"]}, " sub-menu, and choose ", {"type": "ui", "text": ["Inspect flattened stage"]}, " or ", {"type": "ui", "text": ["Inspect active layer"]}, ". These menu items open a viewer window showing the stage/layer as ", {"scheme": null, "value": "usd", "type": "link", "text": [{"type": "code", "text": ["usda"]}, " code"], "fullpath": "/solaris/usd.html"}, ". You can save the ", {"type": "code", "text": ["usda"]}, " code to a file from this window."], "extent": [18341, 18616]}], "container": true}]}], "title": ["Writing out USD"]}