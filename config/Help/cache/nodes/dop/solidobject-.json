{"type": "root", "attrs": {"type": "node", "context": "dop", "internal": "femsolidobject", "icon": "VOP/concrete", "since": "13.0", "version": "", "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Solid Object"], "extent": [86, 103]}, {"type": "summary", "indent": 0, "text": ["Creates a Solid Object from SOP Geometry."], "extent": [103, 153]}, {"type": "para", "indent": 0, "text": ["The Solid Object DOP creates a Solid Object inside the DOP simulation. It creates a new object and attaches the subdata required for it to be a properly conforming Solid Object. Solid Objects can be simulated using the FEM Solver."], "extent": [153, 385]}, {"type": "para", "indent": 0, "text": ["Solid objects are different than rigid bodies. Solid objects are flexible, which makes it possible for them to deform, and can be used to simulate materials such as flesh, wood, and concrete. Solid objects are also able to break dynamically during a simulation, based on the deformation that happens during the simulation."], "extent": [385, 709]}, {"type": "para", "indent": 0, "text": ["You can use a tetrahedral mesh in SOPs to create your solid object. Your solid geometry should satisfy ", {"scheme": null, "value": "/finiteelements/geometry", "type": "link", "text": ["guidelines"], "fullpath": "/finiteelements/geometry.html"}, " that ensure a fast-running and good looking simulation."], "extent": [709, 907]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/finiteelements/", "type": "link", "text": ["the section on solid simulation"], "fullpath": "/finiteelements/index.html"}, " for more information."], "extent": [907, 985]}, {"type": "include_group", "body": [{"ext": "/shelf/femsolidobject#includeme", "type": "include", "indent": 0, "role": "item", "extent": [985, 1028]}], "container": true, "role": "item_group"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1028, 1040], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Model"], "extent": [1040, 1053], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Material Model"], "extent": [16, 32], "body": [{"type": "para", "indent": 4, "text": ["Choose the model that determines how the material resists deformation. The Neo-Hookean material model is useful for simulating biological tissues (e.g., muscles and fat), and requires the ", {"type": "ui", "text": ["Solve Method"]}, " on the ", {"scheme": "Node", "value": "/nodes/dop/femsolver", "type": "link", "text": ["FEM Solver"], "fullpath": "/nodes/dop/femsolver.html"}, " to be set to ", {"type": "ui", "text": ["GNL"]}, "."], "extent": [56, 327]}], "container": true, "attrs": {"id": "materialmodel"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Shape Stiffness"], "extent": [327, 344], "body": [{"type": "para", "indent": 4, "text": ["This determines how strongly the Solid Object resists changes in shape. In the isotropic use case (Anisotropic Strength all 1), this physical constant is also known as shear modulus, modulus of rigidity, or Lame\u2019s second parameter. If the units of length are set to meters, then the Shape Stiffness parameter has units of GPa."], "extent": [369, 701]}], "container": true, "attrs": {"id": "shapestiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Volume Stiffness"], "extent": [701, 719], "body": [{"type": "para", "indent": 4, "text": ["This determines how strongly the Solid Object resists changes in volume. In the isotropic use case (Anisotropic Strength all 1), this physical constant is also known as Lame\u2019s first parameter.  If the units of length are set to meters, then the Shape Stiffness parameter has units of GPa."], "extent": [745, 1039]}], "container": true, "attrs": {"id": "volumestiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Damping Ratio"], "extent": [1039, 1054], "body": [{"type": "para", "indent": 4, "text": ["This value should lie between 0 and 1. It controls the rate of energy loss as a result of the rate of deformation. A value of 0 means that there is no loss of energy due to internal damping forces. A value of 1 means that the object is critically damped, in which case the object comes to rest in the quickest possible way without oscillating. The higher the damping ratio, the less the solid oscillates and the quicker the object\u2019s motion will come to rest. The effect of damping is independent of your geometry\u2019s resolution."], "extent": [1077, 1609]}], "container": true, "attrs": {"id": "dampingratio"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Mass Density"], "extent": [1609, 1623], "body": [{"type": "para", "indent": 4, "text": ["This is the mass per cubed length unit. The mass density can be made lower or higher in parts of the object using the primitive attribute ", {"type": "code", "text": ["volumemassdensity"]}, ", which works as a multiplier for the parameter. The higher the mass density, the less the object tends to accelerate as a result of any internal or external forces (F = m a, Newton\u2019s second law)."], "extent": [1651, 2010]}], "container": true, "attrs": {"id": "volumemassdensity"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enable Fracturing"], "extent": [2010, 2029], "body": [{"type": "para", "indent": 4, "text": ["This enables or disables all fracturing for this object."], "extent": [2060, 2130]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [2130, 2140], "body": [{"type": "para", "indent": 8, "text": ["Before any fracturing can occur, ", {"type": "ui", "text": ["Enable Fracturing"]}, " must also be enabled on the ", {"scheme": "Node", "value": "/nodes/dop/femsolver", "type": "link", "text": ["FEM Solver"], "fullpath": "/nodes/dop/femsolver.html"}, "."], "extent": [2140, 2265]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "enablefracturing"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fracture Threshold"], "extent": [2265, 2285], "body": [{"type": "para", "indent": 4, "text": ["The amount of relative stretch that will cause the geometry to break up into separate parts during the simulation. For example, if the threshold is set to 0.1, the geometry will break in places where there is more than 10% stretch compared to the rest geometry."], "extent": [2313, 2580]}, {"type": "para", "indent": 4, "text": ["Realistic solid objects are not equally strong everywhere, there are weak parts that tend to fracture before any other parts. To create these relatively weaker parts you can create a vertex attribute called ", {"type": "code", "text": ["fracturethreshold"]}, ". This attribute is a multiplier for the ", {"type": "ui", "text": ["Fracture Threshold"]}, " parameter, so that you can still use the ", {"type": "ui", "text": ["Fracture Threshold"]}, " to control the overall strength of the object."], "extent": [2580, 2986]}], "container": true, "attrs": {"id": "fracturethreshold"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Friction Coefficient"], "extent": [2986, 3008], "body": [{"type": "para", "indent": 4, "text": ["The coefficient of friction of the object. A value of 0 means the object is frictionless. This governs how much the velocity that is tangential to the contact plane is affected by collisions. When two objects are in contact, the solver multiplies the friction coefficients of the involved object to get the effective friction coefficient for that contact."], "extent": [3027, 3388]}], "container": true, "attrs": {"id": "friction"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Anisotropic Strength"], "extent": [3388, 3410], "body": [{"type": "para", "indent": 4, "text": ["These values allow you to make the internal forces of the Solid Object behave in an anisotropic way; in that case, the amount of stress will differ depending on the direction in which the object is deformed. An example of an anisotropic material is wood, which has a different strength along the grain than perpendicular to the grain. The ", {"type": "code", "text": ["materialuvw"]}, " vertex or point attribute can be used to specify the internal directions of the Solid Object\u2019s internal force model. For example, in the case of wood, the U direction could be aligned with the grain of the wood, while the VW coordinates are chosen perpendicular to the grain of the wood. In this case, the strength along the grain can be separately controlled using the U component of the ", {"type": "ui", "text": ["Anisotropic Strength"]}, "."], "extent": [3430, 4202]}], "container": true, "attrs": {"id": "aniso"}, "role": "item"}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Geometry"], "extent": [1099, 1114], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Initial Geometry"], "extent": [16, 34], "body": [{"type": "para", "indent": 4, "text": ["This geometry determines the initial simulated state of the object. It determines the initial position and velocity for each of the points."], "extent": [59, 208]}, {"type": "para", "indent": 4, "text": ["This is the geometry that is used for the computation of internal forces and for collision detection. Don\u2019t use more tetrahedrons than you need to get a good looking motion; more tetrahedrons does not always translate to more quality. The fewer tetrahedrons you use, the better the simulation speed is. If extra detail needs to be added, it is recommended that you use the ", {"type": "ui", "text": ["Embedded Geometry"]}, "."], "extent": [208, 609]}, {"type": "para", "indent": 4, "text": ["You can use the Tetrahedralize SOP to create a suitable input mesh. It is important that you enable the quality option on the Tetrahedralize SOP. Otherwise, the interior of your Solid Object won\u2019t have enough degrees of freedom to be flexible."], "extent": [609, 858]}], "container": true, "attrs": {"channels": "/soppath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enable Embedding"], "extent": [0, 18], "body": [{"type": "para", "indent": 4, "text": ["Turns on/off the use of embedded geometry."], "extent": [51, 99]}], "container": true, "attrs": {"channels": "/enableembedding"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Embedded Geometry"], "extent": [99, 118], "body": [{"type": "para", "indent": 4, "text": ["This geometry is embedded into and deformed along with the simulated tetrahedral mesh."], "extent": [152, 244]}], "container": true, "attrs": {"channels": "/embeddedgeometry"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Import Rest Geometry"], "extent": [15, 37], "body": [{"type": "para", "indent": 4, "text": ["This option allows you to specify and animate the rest positions that are used by the simulation inside the SOP network (without having to use a SOP solver). The option defines whether the rest positions should be imported from a SOP geometry node at each frame. When enabled, the solver will copy rest positions from the point attribute ", {"type": "code", "text": ["P"]}, " of the SOP geometry node onto the attribute ", {"type": "code", "text": ["restP"]}, " on the simulation geometry at each frame. If no ", {"type": "code", "text": ["restP"]}, " exists, then the 'P' attribute from the SOP geometry node is copied instead. "], "extent": [73, 610]}], "container": true, "attrs": {"channels": "/importrestgeometry"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Rest Geometry Path"], "extent": [610, 631], "body": [{"type": "para", "indent": 4, "text": ["The path to the SOP node that will serve as the source of the rest positions."], "extent": [665, 748]}], "container": true, "attrs": {"channels": "/restgeometrypath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Import Target Geometry"], "extent": [15, 39], "body": [{"type": "para", "indent": 4, "text": ["This option allows you to specify and animate the target positions that are used by the simulation inside the SOP network (without having to use a SOP solver). The option defines whether the target positions should be imported from a SOP geometry node at each frame. When enabled, the solver will copy target positions from the point attribute ", {"type": "code", "text": ["targetP"]}, " of the SOP geometry node onto the attribute ", {"type": "code", "text": ["targetP"]}, " on the simulation geometry at each frame. If no ", {"type": "code", "text": ["targetP"]}, " exists, then the ", {"type": "code", "text": ["P"]}, " attribute from the SOP geometry node is copied instead."], "extent": [77, 625]}], "container": true, "attrs": {"channels": "/importtargetgeometry"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Target Geometry Path"], "extent": [625, 647], "body": [{"type": "para", "indent": 4, "text": ["The path to the SOP node that will serve as the source of the target positions. The positions should be stored in an attribute with the name ", {"type": "code", "text": ["targetP"]}, ". If this attribute is not found, the ", {"type": "code", "text": ["P"]}, " attribute is used as a fallback. "], "extent": [687, 919]}], "container": true, "attrs": {"channels": "/targetgeometrypath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Stiffness"], "extent": [919, 930], "body": [{"type": "para", "indent": 4, "text": ["This coefficient determines how strongly the finite element solver tries to make the point positions match the target point positions. The solver creates an imaginary potential force for this purpose."], "extent": [961, 1167]}], "container": true, "attrs": {"channels": "/stiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Damping"], "extent": [1167, 1176], "body": [{"type": "para", "indent": 4, "text": ["This coefficient determines how strongly the finite element solver tries to make the point velocities match the target point velocities. The solver creates an imaginary dissipation force for this purpose."], "extent": [1205, 1416]}], "container": true, "attrs": {"channels": "/damping"}, "role": "item"}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Fracturing"], "extent": [1286, 1303], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Fracturing"], "extent": [1303, 1323], "body": [{"type": "para", "indent": 4, "text": ["Allows the tetrahedrons of this object to break apart when impacted beyond the force set by the ", {"type": "ui", "text": ["Fracture threshold"]}, " below. The solver must also have fracturing on (which is the default for the solver)."], "extent": [1356, 1566]}], "container": true, "attrs": {"channels": "enablefracturing"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fracture Threshold"], "extent": [1566, 1586], "body": [{"type": "para", "indent": 4, "text": ["The relative amount of stress in any direction above which dynamic fracturing will occur. This lets you control how quickly the object will break into pieces as a result of stresses inside the object."], "extent": [1620, 1830]}, {"type": "para", "indent": 4, "text": ["Realistic objects don\u2019t have the same fracture threshold everywhere. To achieve this, you can use a point attribute with the name ", {"type": "code", "text": ["fracturethreshold"]}, " that acts as a local multiplier for the per-object fracture threshold. "], "extent": [1830, 2061]}, {"type": "para", "indent": 4, "text": ["It is recommended that you use the primitive attribute ", {"type": "code", "text": ["fracturepart"]}, " to assign integer numbers to clumps of tetrahedrons that should never be broken up into smaller pieces. Creating these clumps prevents individual tetrahedrons from breaking off. The Solid Fracture SOP can be a useful tool for creating this ", {"type": "code", "text": ["fracturepart"]}, " attribute. You can create a ", {"type": "code", "text": ["fracturepart"]}, " on the embedded geometry as well. This way, the fractured pieces in the simulated geometry and the embedded geometry can be properly matched."], "extent": [2061, 2576]}], "container": true, "attrs": {"channels": "fracturethreshold"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Collisions"], "extent": [2576, 2593], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Collide with other objects of different solver"], "extent": [16, 64], "body": [{"type": "para", "indent": 4, "text": ["If enabled, the geometry in this object will collide with all DOP objects that belong to a different solver DOP node. Examples, are ", {"scheme": "Node", "value": "/nodes/dop/staticobject", "type": "link", "text": ["Static Objects"], "fullpath": "/nodes/dop/staticobject.html"}, ", ", {"scheme": "Node", "value": "/nodes/dop/rbdobject", "type": "link", "text": ["RBD Objects"], "fullpath": "/nodes/dop/rbdobject.html"}, ", and the ", {"scheme": "Node", "value": "/nodes/dop/groundplane", "type": "link", "text": ["Ground Plane"], "fullpath": "/nodes/dop/groundplane.html"}, ". When the ", {"type": "ui", "text": ["Collision Detection"]}, " parameter on the Static Object is set to ", {"type": "ui", "text": ["Use Volume Collisions"]}, ", then the polygon vertices will be tested for collision against the signed distance field (SDF) of the Static Object. When ", {"type": "ui", "text": ["Collision Detection"]}, " is set to ", {"type": "ui", "text": ["Use Surface Collisions"]}, ", then geometry-based continuous collision detection is used. The geometry-based collisions collide points against polygons, and edges against edges."], "extent": [93, 786]}, {"type": "para", "indent": 4, "text": ["When surface-based collisions are used, only polygons and tetrahedrons in the ", {"scheme": "Node", "value": "/nodes/dop/staticobject", "type": "link", "text": ["Static Object"], "fullpath": "/nodes/dop/staticobject.html"}, " are considered. Other types of primitives, for example spheres, are be ignored. The geometry of the external objects (e.g. Static Object) is treated as being one-sided; only the outsides of the polygons, determined by the winding order, oppose collisions."], "extent": [786, 1163]}, {"type": "para", "indent": 4, "text": ["When volume-based collisions are enabled, only points will be colliding against the volumes, not the interiors of polygons and tetrahedrons. When colliding against small volumes, this may mean that you need to increase the number of points on your mesh to get accurate collision results."], "extent": [1163, 1456]}], "container": true, "attrs": {"id": "collideindependent"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Collide with other objects of same solver"], "extent": [1456, 1499], "body": [{"type": "para", "indent": 4, "text": ["When enabled, this object will collide with other objects that have the same solver. These collisions are handled using continuous collision detection, based on the geometry (polygons and/or tetrahedrons). For collisions between objects on the same solver, the polygons are treated as two-sided. Both sides of the polygons collide. The surface of a tetrahedral mesh only collides on one side: the outside."], "extent": [1528, 1939]}], "container": true, "attrs": {"id": "collidecodependent"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Collide distinct connected components of this object"], "extent": [1939, 1993], "body": [{"type": "para", "indent": 4, "text": ["If disabled, no two tetrahedrons within this object can collide with each other."], "extent": [2015, 2104]}], "container": true, "attrs": {"id": "collideself"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Self-collide each connected component"], "extent": [2104, 2144], "body": [{"type": "para", "indent": 4, "text": ["If disabled, no two tetrahedrons that belong on the same connected component may collide with each other."], "extent": [2175, 2286]}], "container": true, "attrs": {"id": "collideselfcomponent"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Self-collide within each fracture part (defined by fracturepart primitive attribute)"], "extent": [2286, 2372], "body": [{"type": "para", "indent": 4, "text": ["This option only has an effect when fracturing is enabled on the solver. If disabled, no two tetrahedrons that belong on the same fracture part may collide with each other. Fracture parts are controlled by the integer-valued ", {"type": "code", "text": ["fracturepart"]}, " primitive attribute."], "extent": [2406, 2673]}], "container": true, "attrs": {"id": "collideselffracturepart"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Properties"], "extent": [2890, 2909], "body": [{"type": "include_group", "body": [{"ext": "standard_solidcollision_parms#friction", "type": "include", "indent": 0, "role": "item", "extent": [2909, 2960]}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["External volume properties"], "extent": [2960, 2995], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Division Method"], "extent": [3647, 3664], "body": [{"type": "para", "indent": 4, "text": ["If ", {"type": "ui", "text": ["Non Square"]}, " is chosen, the specified size is divided into the given number\n    of divisions of voxels.  However, the sides of these voxels may not be\n    equal, possibly leading to distorted simulations."], "extent": [3692, 3907]}, {"type": "para", "indent": 4, "text": ["When an axis is specified, that axis is considered authoritative\n    for determining the number of divisions.  The chosen axis' size\n    will be divided by the uniform divisions to yield the voxel\n    size.  The divisions for the other axes will then be adjusted to\n    the closest integer multiple that fits in the required size."], "extent": [3907, 4247]}, {"type": "para", "indent": 4, "text": ["Finally, the size along non-chosen axes will be changed to\n    represent uniform voxel sizes.  If the ", {"type": "ui", "text": ["Max Axis"]}, " option is chosen,\n    the maximum sized axis is used."], "extent": [4247, 4421]}, {"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["By Size"]}, " is chosen, the ", {"type": "ui", "text": ["Division Size"]}, " will be used to\n    compute the number of voxels that fit in the given sized box."], "extent": [4421, 4562]}], "container": true, "attrs": {"id": "sdf_uniformvoxels"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Uniform Divisions"], "extent": [4741, 4760], "body": [{"type": "para", "indent": 4, "text": ["The resolution of the key axis on the voxel grid.  This allows you\n    to control the overall resolution with one parameter and still\n    preserve uniform voxels.  The ", {"type": "ui", "text": ["Uniform Voxels"]}, " option specifies\n    which axis should be used as the reference. It is usually safest\n    to use the maximum axis."], "extent": [4789, 5100]}], "container": true, "attrs": {"id": "sdf_uniformdiv"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tolerance"], "extent": [8820, 8831], "body": [{"type": "para", "indent": 4, "text": ["This specifies the tolerance used for ray intersections\n    when computing the SDF. This value is multiplied by the size\n    of the geometry and is scale invariant."], "extent": [8853, 9027]}], "container": true, "attrs": {"id": "sdf_tol"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sign Sweep Threshold"], "extent": [7441, 7463], "body": [{"type": "para", "indent": 4, "text": ["After the fix signs process is complete there can still be\n    inconsistent areas in the SDF.  Large blocks can become\n    stabilized and stick out of the SDF.  A second sign sweep pass\n    can be performed to try to eliminate these blocks."], "extent": [7492, 7738]}, {"type": "para", "indent": 4, "text": ["The sign sweep threshold governs how big of a jump has to\n    occur for a sign transition to be considered inconsistent.  If\n    the values of the sdf change by more than this threshold times\n    the width of the cell, it is considered an invalid sign\n    transition.  The original geometry is then ray intersected to\n    determine inside/outside and the result used to determine\n    which sign is correct.  The correct sign is then propagated\n    forward through the model."], "extent": [7738, 8222]}], "container": true, "attrs": {"id": "sdf_sweepalpha"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Sign Sweep Count"], "extent": [8222, 8244], "body": [{"type": "para", "indent": 4, "text": ["The sign sweeps are repeated until no signs are flipped (ie,\n    all transitions are within the threshold) or this maximum is\n    reached.  Too low of a sign sweep threshold may prevent the\n    process from converging.  Otherwise, it tends to converge very\n    quickly."], "extent": [8273, 8548]}], "container": true, "attrs": {"id": "sdf_sweepcount"}, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Drag"], "extent": [3243, 3254], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Normal Drag"], "extent": [15, 28], "body": [{"type": "para", "indent": 4, "text": ["The component of drag in the directions normal to the surface.  Increasing this will make the object go along with any wind that blows against it. For realistic wind interaction, the Normal Drag should be chosen larger (about 10 times larger) than the tangent drag."], "extent": [56, 327]}], "container": true, "attrs": {"channels": "/normaldrag"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tangent Drag"], "extent": [327, 341], "body": [{"type": "para", "indent": 4, "text": ["The component of drag in the direction tangent to the surface.  Increasing\n    this will make the object go along with any wind that blows tangent to the\n    object."], "extent": [370, 541]}], "container": true, "attrs": {"channels": "/tangentdrag"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["External Velocity Field"], "extent": [541, 566], "body": [{"type": "para", "indent": 4, "text": ["The name of the external velocity fields on affectors that the object will\n    respond to. The default is ", {"type": "code", "text": ["vel"]}, ", which will make the object react to fluids\n    and smoke when the ", {"type": "ui", "text": ["Tangent Drag"]}, " and the ", {"type": "ui", "text": ["Normal Drag"]}, " have been\n    chosen sufficiently large. The ", {"type": "ui", "text": ["Tangent Drag"]}, " and ", {"type": "ui", "text": ["Normal Drag"]}, " forces\n    are computed by comparing the object\u2019s velocity with the external velocity."], "extent": [605, 999]}], "container": true, "attrs": {"channels": "/externalvelocityfield"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["External Velocity Offset"], "extent": [999, 1025], "body": [{"type": "para", "indent": 4, "text": ["This offset is added to any velocity that\u2019s read from the velocity field.\n    When there\u2019s no velocity field, then the offset can be used to create a\n    wind force which has constant velocity everywhere. This wind effect is\n    more realistic and more accurate than the wind that is generated by DOP\n    Forces."], "extent": [1065, 1382]}], "container": true, "attrs": {"channels": "/externalvelocityoffset"}, "role": "item"}], "container": true}]}, {"level": 2, "id": "visualization", "container": true, "type": "h", "indent": 0, "text": ["Visualization"], "extent": [3294, 3330], "body": []}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Creation"], "extent": [3330, 3346], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Creation Frame Specifies Simulation Frame"], "extent": [16, 59], "body": [{"type": "para", "indent": 4, "text": ["Determines if the creation frame refers to global Houdini\n    frames (", {"type": "code", "text": ["$F"]}, ") or to simulation specific frames (", {"type": "code", "text": ["$SF"]}, ").  The\n    latter is affected by the offset time and scale time at the\n    DOP network level."], "extent": [59, 278]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Creation Frame"], "extent": [278, 294], "body": [{"type": "para", "indent": 4, "text": ["The frame number on which the object will be created. The\n    object is created only when the current frame number is equal to\n    this parameter value. This means the DOP Network must evaluate a\n    timestep at the specified frame, or the object will not be\n    created. "], "extent": [294, 576]}, {"type": "para", "indent": 4, "text": ["For example, if this value is set to 3.5, the\n    ", {"type": "ui", "text": ["Timestep"]}, " parameter of the DOP Network must be changed to\n    ", {"type": "code", "text": ["1/(2*$FPS)"]}, " to ensure the DOP Network has a timestep at frame\n    3.5."], "extent": [576, 772]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number of Objects"], "extent": [772, 791], "body": [{"type": "para", "indent": 4, "text": ["Instead of making a single object, you can create a number of\n    identical objects. You can set each object\u2019s parameters\n    individually by using the ", {"type": "code", "text": ["$OBJID"]}, " expression."], "extent": [791, 973]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Object Name"], "extent": [973, 986], "body": [{"type": "para", "indent": 4, "text": ["The name for the created object. This is the name that shows up\n    in the details view, and is used to reference this object externally. "], "extent": [1007, 1155]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [1155, 1165], "body": [{"type": "para", "indent": 8, "text": ["It is possible to have many objects with the same name, but this complicates writing references, so it is recommended to use something like ", {"type": "code", "text": ["$OBJID"]}, " in the name."], "extent": [1165, 1336]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "object_name"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Solve On Creation Frame"], "extent": [1336, 1361], "body": [{"type": "para", "indent": 4, "text": ["When turned on, newly created objects are solved by the solver on\n    the timestep in which it was created. "], "extent": [1386, 1500]}, {"type": "para", "indent": 4, "text": ["This parameter is usually turned on if this node is creating objects in the middle of a simulation rather than creating objects for the initial state of the simulation."], "extent": [1500, 1674]}], "container": true, "attrs": {"id": "solvefirstframe"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Allow Caching"], "extent": [1674, 1689], "body": [{"type": "para", "indent": 4, "text": ["By preventing a large object from being cached, you can ensure\n    there is enough room in the cache for the previous frames of its\n    collision geometry."], "extent": [1689, 1850]}, {"type": "para", "indent": 4, "text": ["This option should only be set when you are working with a very large sim.\n    It is much better just to use a larger memory cache if possible."], "extent": [1850, 1998]}], "container": true, "role": "item"}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Initial State"], "extent": [3379, 3399], "body": [{"type": "para", "indent": 0, "text": ["Controls on this tab allow you to set the initial states of the object\u2019s position, pivot, rotation, initial velocity, and angular velocity."], "extent": [3399, 3541]}]}, {"level": 2, "id": "attrib", "container": true, "type": "h", "indent": 0, "text": ["Attributes"], "extent": [3541, 3567], "body": [{"type": "para", "indent": 0, "text": ["The finite element solver will recognize and use ", {"scheme": null, "value": "/model/attributes", "type": "link", "text": ["attributes"], "fullpath": "/model/attributes.html"}, " on the simulated geometry. In the DOP network, this simulation geometry is attached to the simulated object as a sim-data with name ", {"type": "code", "text": ["Geometry"]}, ". When an object is created, then the geometry and all the corresponding attributes are read from the ", {"type": "ui", "text": ["Initial Geometry"]}, ". This includes the standard position and velocity point attributes ", {"type": "code", "text": ["P"]}, " and ", {"type": "code", "text": ["v"]}, "."], "extent": [16, 442]}, {"type": "para", "indent": 0, "text": ["The finite element solve supports input attributes and output attributes.\nSome attributes, such as the simulation state, are both input and output attributes.\nThe input attributes include multiplier attributes for material properties,\nfracture attributes, and attributes for controlling target positions and corresponding hard/soft constraints.\nThe output attributes include optional attributes for tet quality, energy densities, FEM node forces, collision info attributes and fracture info attributes."], "extent": [442, 946]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Material Property Multiplier Attributes"], "extent": [946, 992], "body": [{"type": "para", "indent": 0, "text": ["Each of the material properties of a simulated object can be locally modified using multiplier point attributes. As a rule, each of the material properties in the ", {"type": "ui", "text": ["Model"]}, " tab of an object can be affected by a multiplier attribute. As a rule, the name of the parameter is the name of the attribute. The name of the attribute is the name that is displayed after ", {"type": "q", "text": ["Parameter:"]}, " when you hover over a parameter with your mouse cursor."], "extent": [992, 1425]}, {"type": "para", "indent": 0, "text": ["You can locally change the material properties of the object using point attributes.\nFor example, you can make some polygons resists stretching and bending more than other polygons.\nThese attributes work as multipliers for the parameters in the ", {"type": "ui", "text": ["Model"]}, " tab:\nThe stiffness multiplier is a convenient way to modify the local stiffness for all object types that are recognized by the finite element solver:"], "extent": [1425, 1832]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [1832, 1840], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [1840, 1849], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [1849, 1867]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [1867, 1886]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [1886, 1904]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [1904, 1929]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [1929, 1938], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["stiffness"]}], "extent": [1938, 1963]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [1963, 1982]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [1982, 2001]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for all types of stiffness."], "extent": [2001, 2053]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [2053, 2062], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["dampingratio"]}], "extent": [2062, 2090]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [2090, 2109]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [2109, 2128]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for all damping ratios."], "extent": [2128, 2176]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [2176, 2185], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["massdensity"]}], "extent": [2185, 2212]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [2212, 2231]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [2231, 2250]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for all mass densities."], "extent": [2250, 2298]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["For solid objects, the following multiplier point attributes can be used to modify the local behavior:"], "extent": [2298, 2403]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [2403, 2411], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [2411, 2420], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [2420, 2438]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [2438, 2457]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [2457, 2475]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [2475, 2500]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [2500, 2509], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["solidstiffness"]}], "extent": [2509, 2539]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [2539, 2558]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [2558, 2577]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for both the shape stiffness and the volume stiffness of a Solid Object."], "extent": [2577, 2674]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [2674, 2683], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["solidshapestiffness"]}], "extent": [2683, 2718]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [2718, 2737]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [2737, 2756]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the shape stiffness of a Solid Object."], "extent": [2756, 2823]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [2823, 2832], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["solidvolumestiffness"]}], "extent": [2832, 2868]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [2868, 2887]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [2887, 2906]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the volume stiffness of a Solid Object."], "extent": [2906, 2974]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [2974, 2983], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["solidmassdensity"]}], "extent": [2983, 3015]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [3015, 3034]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [3034, 3053]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the mass density of a Solid Object."], "extent": [3053, 3117]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Collision Control Attributes"], "extent": [3117, 3153], "body": [{"type": "para", "indent": 0, "text": ["The FEM solver looks at collision identifiers to decide which primitive pairs are allowed to collide.\nThe rule is that a pair of primitives may collide if they have the same collision identifier.\n(This mechanism may possibly be extended in a future release, allowing the user to specify exactly which collision identifier pairs may collide.)\nCollisions can be suppressed altogether for certain primitives by setting the special value -1.\nA collision id may be specified separately for the interior and the exterior side of each polygon and tetrahedron.\nThe exterior side of a polygon is decided using the winding order convention, just like the normal direction.\nIf ", {"type": "code", "text": ["interiorcollisionid"]}, " is not specified, then the default collision id of 0 is used for triangles, but interior collisions are disabled for tets.\nIf ", {"type": "code", "text": ["exteriorcollisionid"]}, " is not specified, then the default collision id of 0 is used for both tets and triangles."], "extent": [3153, 4081]}, {"type": "para", "indent": 0, "text": ["Consider, as an example, an FEM muscle simulation, we may want the muscles to collide only with the interior side of the skin polygons, so the ", {"type": "code", "text": ["exteriorcollisionid"]}, " for those polygons may be set to -1 (disable)."], "extent": [4081, 4294]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [4294, 4302], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [4302, 4311], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [4311, 4329]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [4329, 4348]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [4348, 4366]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [4366, 4391]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [4391, 4400], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["exteriorcollisionid"]}], "extent": [4400, 4435]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [4435, 4458]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Integer"], "extent": [4458, 4479]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Collision identifier for the exterior side of a polygon or tet surface"], "extent": [4479, 4563]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [4563, 4572], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["interiorcollisionid"]}], "extent": [4572, 4607]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [4607, 4630]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Integer"], "extent": [4630, 4651]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Collision identifier for the interior side of a polygon or tet surface"], "extent": [4651, 4735]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["The following attributes can be used to locally multiply the ", {"type": "ui", "text": ["Repulsion"]}, " and ", {"type": "ui", "text": ["Friction"]}, " parameters:"], "extent": [4735, 4841]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [4841, 4849], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [4849, 4858], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [4858, 4876]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [4876, 4895]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [4895, 4913]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [4913, 4938]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [4938, 4947], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["repulsion"]}], "extent": [4947, 4972]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [4972, 4995]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [4995, 5014]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the ", {"type": "ui", "text": ["Repulsion"]}, " of an FEM Object"], "extent": [5014, 5077]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [5077, 5086], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["friction"]}], "extent": [5086, 5110]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [5110, 5133]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [5133, 5152]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the ", {"type": "ui", "text": ["Friction"]}, " of an FEM Object"], "extent": [5152, 5214]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Material Space Attributes"], "extent": [5214, 5247], "body": [{"type": "para", "indent": 0, "text": ["The attribute ", {"type": "code", "text": ["materialP"]}, " can be thought of as the positions of the simulated object in the material space.\n", {"type": "code", "text": ["materialP"]}, " is the undeformed configuration relative to which the current position ", {"type": "code", "text": ["P"]}, " determines the deformation of a simulated object. \n", {"type": "code", "text": ["materialP"]}, " must stay the same throughout the entire simulation.\nThe finite element solver relies on assumption that the ", {"type": "code", "text": ["materialP"]}, " attribute remains unchanged from frame to frame; it should never be modified externally (e.g., through a SOP solver) otherwise bad simulation results will be produced."], "extent": [5247, 5796]}, {"type": "para", "indent": 0, "text": ["In the case where no ", {"type": "ui", "text": ["Rest Shape"]}, " is specified and nor ", {"type": "code", "text": ["restP"]}, " attribute is provided, ", {"type": "code", "text": ["materialP"]}, " can be thought of as a permanent rest position.\nIf no animation of the rest position is required in a sim, only ", {"type": "code", "text": ["materialP"]}, " should be specified (no ", {"type": "code", "text": ["restP"]}, ").\nAt any stage in the simulation, it is the mapping from ", {"type": "code", "text": ["materialP"]}, " to the current ", {"type": "code", "text": ["P"]}, " that determines the deformation of tets in simulated objects.\nThe deformation in turn defines the energy stored inside the object."], "extent": [5796, 6272]}, {"type": "para", "indent": 0, "text": ["To help determine the anisotropic behavior of solids, including fiber contraction, the solver can makes use of local UVW frames. These UVW frames may be specified directly using the vertex/point attributes ", {"type": "code", "text": ["materialU"]}, ", ", {"type": "code", "text": ["materialV"]}, ", and ", {"type": "code", "text": ["materialW"]}, ". Alternatively, they may be inferred from UVW positions that may be specified by a vertex/point position attribute ", {"type": "code", "text": ["materialuvw"]}, ". The FEM solver embeds the UVW directions within the material space that may be specified by the attribute ", {"type": "code", "text": ["materialP"]}, ". To get the correct idea of how this works, UVW directions that are fed into the FEM solver should be visualized relative to the material position ", {"type": "code", "text": ["materialP"]}, "."], "extent": [6272, 6929]}, {"type": "para", "indent": 0, "text": ["For FEM muscle simulations, the easiest way to specify the muscle fiber direction is through vertex/point attribute ", {"type": "code", "text": ["materialW"]}, ". It is fine if no ", {"type": "code", "text": ["materialU"]}, " and ", {"type": "code", "text": ["materialV"]}, " directions are specified in this case, as the solver will infer arbitrary ", {"type": "code", "text": ["materialU"]}, " and ", {"type": "code", "text": ["materialV"]}, " directions from ", {"type": "code", "text": ["materialW"]}, " in that case."], "extent": [6929, 7248]}, {"type": "para", "indent": 0, "text": ["The attribute ", {"type": "code", "text": ["materialuvw"]}, " can be used to specify a UVW parametrization of the material space.\nThe U, V and W directions that are implied by ", {"type": "code", "text": ["materialuvw"]}, " matter if the anisotropic controls are used or when the fiber controls are used on a simulated object.\nFor the FEM muscle simulation use case, the fiber controls are an important tool for controlling muscle contraction."], "extent": [7248, 7625]}, {"type": "para", "indent": 0, "text": ["Similar to ", {"type": "code", "text": ["materialuvw"]}, ", the ", {"type": "code", "text": ["materialuv"]}, " attribute can be used to specify UV directions for cloth. This attribute is essential for triangle meshes, in particular, to define the warped and weft directions for cloth."], "extent": [7625, 7843]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [7843, 7851], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [7851, 7860], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [7860, 7878]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [7878, 7897]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [7897, 7915]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [7915, 7940]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [7940, 7949], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["materialP"]}], "extent": [7949, 7974]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [7974, 8003]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [8003, 8023]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Material position of each point, defining the material space"], "extent": [8023, 8097]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [8097, 8106], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["materialU"]}], "extent": [8106, 8131]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [8131, 8160]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [8160, 8180]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" The U direction within the material space"], "extent": [8180, 8235]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [8235, 8244], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["materialV"]}], "extent": [8244, 8269]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [8269, 8298]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [8298, 8318]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" The V direction within the material space"], "extent": [8318, 8373]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [8373, 8382], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["materialW"]}], "extent": [8382, 8407]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [8407, 8436]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [8436, 8456]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" The W direction within the material space"], "extent": [8456, 8511]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [8511, 8520], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["materialuvw"]}], "extent": [8520, 8547]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [8547, 8576]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [8576, 8596]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Local material uvw coordinates for each point or vertex of a tet."], "extent": [8596, 8675]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [8675, 8684], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["materialuv"]}], "extent": [8684, 8710]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [8710, 8739]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [8739, 8759]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Local material uvw coordinates for each point or vertex of a polygon or polysoup."], "extent": [8759, 8854]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Material Property Multiplier Attributes"], "extent": [8854, 8901], "body": [{"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [8901, 8910], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [8910, 8919], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fracturepart"]}], "extent": [8919, 8947]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [8947, 8970]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Integer"], "extent": [8970, 8991]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Partitions the object into unbreakable parts. Must be either -1 (no part) or a nonnegative number that indicates a part."], "extent": [8991, 9125]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [9125, 9134], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["enablefracturing"]}], "extent": [9134, 9166]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point/Vertex"], "extent": [9166, 9192]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Integer"], "extent": [9192, 9213]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Locally enable/disable fracturing for points or vertices."], "extent": [9213, 9284]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [9284, 9293], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fracturethreshold"]}], "extent": [9293, 9326]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point/Vertex"], "extent": [9326, 9352]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [9352, 9371]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the object\u2019s ", {"type": "ui", "text": ["Fracture Threshold"]}, "."], "extent": [9371, 9436]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Fracturing Control Attributes"], "extent": [9436, 9473], "body": [{"type": "para", "indent": 0, "text": ["When you create a simulation with fracturing, it is recommended to specify chunks of tetrahedrons that you want to stay together. Otherwise, the fracturing process may create a very large amount of separate pieces, many of which may consist of single tetrahedrons. For this purpose, you can assign a nonnegative integer to each chunk using the ", {"type": "code", "text": ["fracturepart"]}, " attribute. In areas where you don\u2019t want to specify parts, you can set ", {"type": "code", "text": ["fracturepart"]}, " to -1, which means that each primitive in that region will become its own part. Real-life materials tend not to be equally strong everywhere. For realistic results, it is recommended to vary the ", {"type": "ui", "text": ["Fracture Threshold"]}, " locally using the vertex attribute ", {"type": "code", "text": ["fracturethreshold"]}, "."], "extent": [9473, 10194]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [10194, 10202], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [10202, 10211], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fracturepart"]}], "extent": [10211, 10239]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [10239, 10262]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Integer"], "extent": [10262, 10283]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Partitions the object into unbreakable parts. Must be either -1 (no part) or a nonnegative number that indicates a part."], "extent": [10283, 10417]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [10417, 10426], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["enablefracturing"]}], "extent": [10426, 10458]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point/Vertex"], "extent": [10458, 10484]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Integer"], "extent": [10484, 10505]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Locally enable/disable fracturing for points or vertices."], "extent": [10505, 10576]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [10576, 10585], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fracturethreshold"]}], "extent": [10585, 10618]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point/Vertex"], "extent": [10618, 10644]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [10644, 10663]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the object\u2019s ", {"type": "ui", "text": ["Fracture Threshold"]}, "."], "extent": [10663, 10728]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Drag Force Control Attributes"], "extent": [10728, 10765], "body": [{"type": "para", "indent": 0, "text": ["The behavior of the drag force can be modified locally using the following attributes:"], "extent": [10765, 10854]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [10854, 10862], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [10862, 10871], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["normaldrag"]}], "extent": [10871, 10897]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [10897, 10920]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [10920, 10939]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the object\u2019s ", {"type": "ui", "text": ["Normal Drag"]}, "."], "extent": [10939, 10997]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [10997, 11006], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["tangentdrag"]}], "extent": [11006, 11033]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [11033, 11056]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [11056, 11075]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the object\u2019s ", {"type": "ui", "text": ["Tangent Drag"]}, "."], "extent": [11075, 11134]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Reference Attributes"], "extent": [11134, 11177], "body": [{"type": "para", "indent": 0, "text": ["The attribute ", {"type": "code", "text": ["baseP"]}, " can be used to specify a generic base position for all the object points. This attribute\u2019s values must not be changed during a simulation. When the user does not specify ", {"type": "code", "text": ["baseP"]}, ", the solver creates this point attribute based on the point positions on the creation frame. This attribute is used as a fallback; whenever the user does not specify ", {"type": "code", "text": ["materialP"]}, ", the attribute ", {"type": "code", "text": ["baseP"]}, " is read instead. In the same way, ", {"type": "code", "text": ["baseP"]}, " is used as a fallback for when no ", {"type": "code", "text": ["restP"]}, " or ", {"type": "code", "text": ["targetP"]}, " attributes are provided. Finally, ", {"type": "code", "text": ["baseP"]}, " is used to bind the simulated and the embedded geometry, in the embedded workflow (e.g., a T-pose). This embedded binding looks at the ", {"type": "code", "text": ["baseP"]}, " position attribute on both the simulated geometry and the embedded geometry. If no ", {"type": "code", "text": ["baseP"]}, " attribute is provided by the user on the embedded geometry, the solver creates the ", {"type": "code", "text": ["baseP"]}, " attribute on the embedded geometry based on the position ", {"type": "code", "text": ["P"]}, " at the creation frame.  "], "extent": [11177, 12129], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [12129, 12138], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["baseP"]}], "extent": [12138, 12159]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [12159, 12178]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [12178, 12198]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" base position of each point"], "extent": [12198, 12239]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["If ", {"type": "ui", "text": ["Allow Changing Rest"]}, " is enabled on the FEM Solver, then the attribute ", {"type": "code", "text": ["restP"]}, " may be used to modify rest positions. The attribute ", {"type": "code", "text": ["restP"]}, " can be used to specify an animated rest position for all the object points. For example, at each frame ", {"type": "code", "text": ["restP"]}, " may be modified in a SOP Solver before the finite element solver. Among other things this makes it possible to create plastic deformation kinds of effects. When the rest should stay the same during an entire simulation the attribute ", {"type": "code", "text": ["restP"]}, " should not be used. In that case, it is sufficient to specify only an attribute ", {"type": "code", "text": ["materialP"]}, ", which would act as a permanent, unchanged rest position. If no attribute ", {"type": "code", "text": ["materialP"]}, " is specified, the solver falls back to the ", {"type": "code", "text": ["baseP"]}, " attribute that gets automatically created at the creation frame.\ntable>>"], "extent": [12239, 13038], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [13038, 13047], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [13047, 13065]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [13065, 13084]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [13084, 13102]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [13102, 13127]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [13127, 13136], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["restP"]}], "extent": [13136, 13157]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point/Vertex"], "extent": [13157, 13183]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [13183, 13203]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Rest position of each point."], "extent": [13203, 13245]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Target Attributes"], "extent": [13245, 13286], "body": [{"type": "para", "indent": 0, "text": ["Target attributes can be used to make a simulated object partially follow a target animation. The attribute ", {"type": "code", "text": ["targetP"]}, " can be used to specify a target position for each object point. When you use the ", {"type": "ui", "text": ["Import Target Geometry"]}, " option on the simulated object, the ", {"type": "code", "text": ["targetP"]}, " will be set automatically every frame. Alternatively, you can create and modify these attributes yourself, using a ", {"scheme": "Node", "value": "/nodes/dop/multisolver", "type": "link", "text": ["Multi Solver"], "fullpath": "/nodes/dop/multisolver.html"}, " and a ", {"scheme": "Node", "value": "/nodes/dop/sopsolver", "type": "link", "text": ["SOP Solver"], "fullpath": "/nodes/dop/sopsolver.html"}, ". The target positions and velocities allow the user to mix animation and simulation in a very stable way (assuming the ", {"type": "ui", "text": ["Target Strength"]}, " and ", {"type": "ui", "text": ["Target Damping"]}, " parameters have been set on the object). You can set the ", {"type": "ui", "text": ["Target Strength"]}, " and ", {"type": "ui", "text": ["Target Damping"]}, " parameters on the object to express how strongly the object should match the target position and velocity, respectively. This is a way to create soft constraints. You can use the ", {"type": "code", "text": ["pintoanimation"]}, " to create hard constraints that make the simulated points follow ", {"type": "code", "text": ["targetP"]}, " exactly."], "extent": [13286, 14299]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [14299, 14307], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [14307, 14316], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [14316, 14334]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [14334, 14353]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [14353, 14371]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [14371, 14396]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [14396, 14405], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["targetP"]}], "extent": [14405, 14428]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [14428, 14457]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [14457, 14477]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Target position of each point."], "extent": [14477, 14521]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [14521, 14530], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["targetstrength"]}], "extent": [14530, 14560]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [14560, 14579]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [14579, 14598]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the object\u2019s ", {"type": "ui", "text": ["Target Strength"]}, ". If this attribute is missing, a multiplier of 1 is used at all points."], "extent": [14598, 14731]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [14731, 14740], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["targetdamping"]}], "extent": [14740, 14769]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [14769, 14788]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [14788, 14807]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the object\u2019s ", {"type": "ui", "text": ["Target Damping"]}, ". If this attribute is missing, a multiplier of 1 is used at all points."], "extent": [14807, 14939]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [14939, 14948], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["pintoanimation"]}], "extent": [14948, 14978]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [14978, 14997]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Int"], "extent": [14997, 15014]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" When 1, the point is hard constrained to the target animation (e.g., ", {"type": "code", "text": ["targetP"]}, "). When zero, the point is unconstrained."], "extent": [15014, 15147]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Fiber Attributes"], "extent": [15147, 15171], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["fiberscale"]}, " point attribute acts as a multiplier for the rest strain in the fiber direction.\nThe fiber direction itself can be specified using the ", {"type": "code", "text": ["materialW"]}, " vertex/point attribute.\nAmong other things, this is useful for FEM muscle simulations.\nIf the ", {"type": "code", "text": ["fiberscale"]}, " is changed from 1 to 0.5, then the muscle wants to be half as long as before in the direction of the fiber.\nIf you animate the ", {"type": "code", "text": ["fiberscale"]}, " in a SOP Solver such that it decreases from 1 to a smaller value, you will cause a muscle contraction in the sim."], "extent": [15171, 15698]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["fiberstiffness"]}, " point attribute acts as a multiplier for the stiffness along the fiber direction.\nThe fiber direction of the material is determined by the W axis of the ", {"type": "code", "text": ["materialuvw"]}, " coordinates.\n", {"type": "code", "text": ["fiberstiffness"]}, " works as a multiplier on top of all the other material property multipliers, including the anisotropic multipliers.\nIf the ", {"type": "code", "text": ["fiberstiffness"]}, " changed from 1 to 10, then the stiffness along the fiber direction becomes 10 stronger than before.\nThis can be used to control how strong and how quick the effect of muscle flexing using the ", {"type": "code", "text": ["fiberscale"]}, " attribute takes effect. "], "extent": [15698, 16287]}, {"type": "para", "indent": 0, "text": ["For ", {"type": "code", "text": ["fiberscale"]}, "/", {"type": "code", "text": ["fiberstiffness"]}, " to have the desired effect, it is important that UVW directions are specified.\nA material-space UVWs for FEM muscles can be specified using the ", {"type": "code", "text": ["materialuvw"]}, " point/vertex attribute.\nBy providing ", {"type": "code", "text": ["materialuvw"]}, " as a vertex attribute, you are able to provide a local UVW space for each individual tet, which gives you to option of providing a separate UVW frame to each tet."], "extent": [16287, 16694]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [16694, 16702], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [16702, 16711], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [16711, 16729]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [16729, 16748]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [16748, 16766]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [16766, 16791]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [16791, 16800], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fiberstiffness"]}], "extent": [16800, 16830]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [16830, 16849]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [16849, 16868]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for stiffness along the fiber direction, the W direction implied by ", {"type": "code", "text": ["materialuvw"]}, "."], "extent": [16868, 16975]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [16975, 16984], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fiberscale"]}], "extent": [16984, 17010]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [17010, 17029]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [17029, 17048]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Multiplier for the rest strain along the fiber direction, the W direction implied by ", {"type": "code", "text": ["materialuvw"]}, "."], "extent": [17048, 17161]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["State Attributes"], "extent": [17161, 17185], "body": [{"type": "para", "indent": 0, "text": ["Below is a list of attributes that are maintained internally by the solver. Each of these attributes is written to at the end of each solve and read from at the start of the next solve. You should not modify any of these attributes yourself. When you do, the solver is likely to become unstable and you will get bad results. However, you can inspect the values in these attributes in your network for visualization or for the creation of secondary effects."], "extent": [17185, 17644]}, {"type": "para", "indent": 0, "text": ["At each frame, the finite element solver computes a new physical state for each simulated object. The physical state of the object is represented by the point attributes ", {"type": "code", "text": ["P"]}, " and ", {"type": "code", "text": ["v"]}, ", representing the position and velocity, respectively. The solver\u2019s integration scheme maintains additional attributes ", {"type": "code", "text": ["a"]}, " for acceleration and ", {"type": "code", "text": ["j"]}, " for jerk."], "extent": [17644, 17985]}, {"type": "para", "indent": 0, "text": ["The point attributes ", {"type": "code", "text": ["P"]}, ", ", {"type": "code", "text": ["v"]}, ", ", {"type": "code", "text": ["a"]}, ", and ", {"type": "code", "text": ["j"]}, " store the current integration state of the object. These attributes should not be modified during the simulation because the finite element solver will become unstable and produce low-quality results."], "extent": [17985, 18231]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [18231, 18239], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [18239, 18248], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [18248, 18266]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [18266, 18285]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [18285, 18303]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [18303, 18328]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [18328, 18337], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["P"]}], "extent": [18337, 18354]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [18354, 18373]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [18373, 18393]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Do not modify! Current position of each object point."], "extent": [18393, 18460]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [18460, 18469], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["v"]}], "extent": [18469, 18486]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [18486, 18505]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [18505, 18525]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Do not modify! Current velocity of each object point."], "extent": [18525, 18592]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 3, "extent": [18592, 18600], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["accel"]}], "extent": [18600, 18621]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [18621, 18640]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [18640, 18660]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Do not modify! Current acceleration of each object point."], "extent": [18660, 18731]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 3, "extent": [18731, 18739], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["jerk"]}], "extent": [18739, 18759]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [18759, 18778]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [18778, 18798]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Do not modify! Current jerk of each object point."], "extent": [18798, 18861]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Embedded Geometry Attributes"], "extent": [18861, 18897], "body": [{"type": "para", "indent": 0, "text": ["These attributes are created on the Embedded Geometry of the Solid Object.\nThe ", {"type": "code", "text": ["parent"]}, " attribute is maintained by the embedding code itself, and\nshould not be modified.\nThe ", {"type": "code", "text": ["baseP"]}, " point attribute can be provided on the Embedded Geometry by the user to control the binding between the simulated geometry and the embedded geometry.\nIf no ", {"type": "code", "text": ["baseP"]}, " is provided, it will be copied from the point positions stored in ", {"type": "code", "text": ["P"]}, " at the creation frame.\nThe alignment happens relative to the ", {"type": "code", "text": ["baseP"]}, " point attribute on the simulated geometry. If the simulated geometry has a ", {"type": "code", "text": ["materialP"]}, " vertex or point attribute, then this attribute takes precedence, allowing control per vertex, rather than per point, if necessary.\nWhen you want to ensure that embedded geometry ends up on the desired side of a fracture between simulated geometry, you can use the combination of vertex attributes ", {"type": "code", "text": ["baseP"]}, " on the embedded geometry and ", {"type": "code", "text": ["restP"]}, " on the simulated geometry.\nThis allows you to line up the embedded geometry with the separate parts in the simulated geometry, for example using the ", {"scheme": "Node", "value": "/nodes/sop/explodedview", "type": "link", "text": ["Exploded View SOP"], "fullpath": "/nodes/sop/explodedview.html"}, ".\nThe ", {"type": "code", "text": ["fracturepart"]}, " attribute allows you to make sure that the embedded geometry follows the right parts when it gets fractured. When both the simulated and the embedded geometry have the ", {"type": "code", "text": ["fracturepart"]}, " attribute, the finite element solver will parent embedded geometry to simulated geometry that has the same fracture part."], "extent": [18897, 20329]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [20329, 20337], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [20337, 20346], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [20346, 20364]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [20364, 20383]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [20383, 20401]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [20401, 20426]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [20426, 20435], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["parent"]}], "extent": [20435, 20457]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [20457, 20480]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [20480, 20499]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" The index of a parent primitive in the simulated geometry."], "extent": [20499, 20571]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [20571, 20580], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["baseP"]}], "extent": [20580, 20601]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [20601, 20620]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [20620, 20639]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Base positions used for alignment with simulated mesh."], "extent": [20639, 20707]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [20707, 20716], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fracturepart"]}], "extent": [20716, 20744]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [20744, 20773]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [20773, 20792]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Optional user-specified fracture part ID."], "extent": [20792, 20847]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [20847, 20856], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["P"]}], "extent": [20856, 20873]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [20873, 20892]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [20892, 20911]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Positions that correspond to the deformed state."], "extent": [20911, 20973]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [20973, 20982], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["v"]}], "extent": [20982, 20999]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [20999, 21018]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [21018, 21037]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Velocities that correspond to the deformed state."], "extent": [21037, 21100]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [21100, 21109], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["N"]}], "extent": [21109, 21126]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point or Vertex"], "extent": [21126, 21155]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [21155, 21174]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Normals that correspond to the deformed state."], "extent": [21174, 21234]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Optional Output Attributes"], "extent": [21234, 21268], "body": [{"type": "para", "indent": 0, "text": ["These are attributes that are optionally generated by the solver, when the generation is enabled on the simulated object. These attributes can be useful for visualization, for example, using the Finite Element Visualization SOP. Additionally, these attributes may be used to create secondary effects, for example, particles flying off in regions where fracturing occurs. The optional output attributes are also expected by the Finite Element Visualization SOP."], "extent": [21268, 21731]}, {"type": "para", "indent": 0, "text": ["The following attribute is generated when ", {"type": "ui", "text": ["Create Quality Attributes"]}, " is turned on:"], "extent": [21731, 21818]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [21818, 21826], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [21826, 21835], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [21835, 21853]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [21853, 21872]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [21872, 21890]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [21890, 21915]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [21915, 21924], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["quality"]}], "extent": [21924, 21947]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Primitive"], "extent": [21947, 21970]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [21970, 21989]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" A quality metric between 0 (worst) and 1 (best)"], "extent": [21989, 22050]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["Finite element simulation tends to be sensitive to the quality of the incoming primitives. Low quality primitives may slow down, destabilize or lock a finite element simulation. Low quality primitives are best avoided by using the Tet Embed as a tool to create your tet mesh. Although various quality metrics exist for tetrahedra, the one that\u2019s generated by the solver in this attribute is the one that best matches Houdini\u2019s finite element solution."], "extent": [22050, 22504]}, {"type": "para", "indent": 0, "text": ["The solver generates energy-density attributes for each object that has ", {"type": "ui", "text": ["Create Energy Attributes"]}, " turned on. The material property settings in the Model tab and the corresponding multiplier attributes result in potential energy, energy dissipation and kinetic energy.\nFor each of these three contributions, local densities are computed within the solver. These densities and quantities derived from them are used to determine the motion and behavior of the objects that are solved by the finite element solver."], "extent": [22504, 23019]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [23019, 23027], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [23027, 23036], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [23036, 23054]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [23054, 23073]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [23073, 23091]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [23091, 23116]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [23116, 23125], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["potentialdensity"]}], "extent": [23125, 23157]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [23157, 23176]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [23176, 23195]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" The local density of deformation energy"], "extent": [23195, 23248]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [23248, 23257], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["dissipationdensity"]}], "extent": [23257, 23291]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [23291, 23310]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [23310, 23329]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" The local density of the rate of energy loss"], "extent": [23329, 23387]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [23387, 23396], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["kineticdensity"]}], "extent": [23396, 23426]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [23426, 23445]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Float"], "extent": [23445, 23464]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" The local density of the kinetic energy"], "extent": [23464, 23517]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["potentialdensity"]}, " attribute is directly affected by the stiffness parameters in the Model tab. The ", {"type": "code", "text": ["kineticdensity"]}, " is proportional to the mass density that is specified for the object. The ", {"type": "code", "text": ["dissipationdensity"]}, " is related to the damping settings."], "extent": [23517, 23771]}, {"type": "para", "indent": 0, "text": ["If ", {"type": "ui", "text": ["Create Fracture Attributes"]}, " is enabled on the simulated object, then the ", {"type": "code", "text": ["fracturecount"]}, " point attribute is created.\nThe point attribute ", {"type": "code", "text": ["fracturecount"]}, " maintains for each point, the number of times that the point has been involved in a fracture. So any point with a nonzero value of ", {"type": "code", "text": ["fracturecount"]}, " has been involved fracturing."], "extent": [23771, 24108]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [24108, 24116], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [24116, 24125], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [24125, 24143]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [24143, 24162]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [24162, 24180]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [24180, 24205]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [24205, 24214], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fracturecount"]}], "extent": [24214, 24243]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Point"], "extent": [24243, 24262]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Integer"], "extent": [24262, 24283]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" The number of times a point was fractured during the simulation"], "extent": [24283, 24360]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Legacy Attributes"], "extent": [24360, 24385], "body": [{"type": "para", "indent": 0, "text": ["In most situations where you want to influence a finite-element simulation, you will want to use soft constraints to achieve this, for example, target constraints, region constraints, or the target strength/damping settings on the object. These are first-class solver features that work in a stable way with the solver and should produce high quality results when used correctly. Purely for backwards compatibility, a force attribute is still supported. Because the force attribute lacks essential information that the solver needs, this attribute cannot be relied on when stability and quality are important. When setting up a new sim, alternatives such as soft targeting, region constraints and animated rest positions should be considered instead of the force attribute."], "extent": [24385, 25162]}, {"tag": "table", "attrs": {}, "type": "pxml", "indent": 0, "extent": [25162, 25170], "body": [{"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [25170, 25179], "body": [{"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Name"], "extent": [25179, 25197]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Class"], "extent": [25197, 25216]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Type"], "extent": [25216, 25234]}, {"tag": "th", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Description"], "extent": [25234, 25259]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [25259, 25268], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["fexternal"]}], "extent": [25268, 25293]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Force"], "extent": [25293, 25312]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [25312, 25332]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" External force density"], "extent": [25332, 25368]}], "container": true}, {"tag": "tr", "attrs": {}, "type": "pxml", "indent": 4, "extent": [25368, 25377], "body": [{"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" ", {"type": "code", "text": ["force"]}], "extent": [25377, 25398]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Force"], "extent": [25398, 25417]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Vector"], "extent": [25417, 25437]}, {"tag": "td", "attrs": {}, "type": "pxml", "indent": 8, "text": [" Another name for external force density"], "extent": [25437, 25490]}], "container": true}], "container": true}]}]}], "text": "Parameters"}, {"level": 1, "id": "locals", "container": true, "type": "locals_section", "indent": 0, "role": "section", "extent": [3604, 3612], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["ST"], "extent": [16, 20], "body": [{"type": "para", "indent": 4, "text": ["The simulation time for which the node is being evaluated. "], "extent": [20, 89]}, {"type": "para", "indent": 4, "text": ["Depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP Network"], "fullpath": "/nodes/obj/dopnet.html"}, " \n    ", {"type": "ui", "text": ["Offset Time"]}, " and ", {"type": "ui", "text": ["Scale Time"]}, " parameters, \n    this value may not be equal to the current Houdini time\n    represented by the variable T. "], "extent": [89, 310]}, {"type": "para", "indent": 4, "text": ["ST is guaranteed to have a value of zero at the\n    start of a simulation, so when testing for the first timestep of a\n    simulation, it is best to use a test like ", {"type": "code", "text": ["$ST == 0"]}, ", rather than\n    ", {"type": "code", "text": ["$T == 0"]}, " or ", {"type": "code", "text": ["$FF == 1"]}, "."], "extent": [310, 533]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SF"], "extent": [533, 537], "body": [{"type": "para", "indent": 4, "text": ["The simulation frame (or more accurately, the \n    simulation time step number) for which the node is being evaluated."], "extent": [537, 665]}, {"type": "para", "indent": 4, "text": ["Depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP Network"], "fullpath": "/nodes/obj/dopnet.html"}, " parameters, \n    this value may not be equal to the current Houdini frame number\n    represented by the variable F. Instead, it is equal to\n    the simulation time (ST) divided by the simulation timestep size \n    (TIMESTEP)."], "extent": [665, 959]}], "container": true}, {"type": "dt", "indent": 0, "text": ["TIMESTEP"], "extent": [959, 969], "body": [{"type": "para", "indent": 4, "text": ["The size of a simulation timestep. This value is\n    useful for scaling values that are expressed in units per second, but\n    are applied on each timestep."], "extent": [969, 1131]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SFPS"], "extent": [1131, 1137], "body": [{"type": "para", "indent": 4, "text": ["The inverse of the TIMESTEP value. It is the number\n    of timesteps per second of simulation time."], "extent": [1137, 1242]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SNOBJ"], "extent": [1242, 1249], "body": [{"type": "para", "indent": 4, "text": ["The number of objects in the simulation. For nodes that\n    create objects such as the ", {"scheme": "Node", "value": "/nodes/dop/emptyobject", "type": "link", "text": ["Empty Object DOP"], "fullpath": "/nodes/dop/emptyobject.html"}, ",\n    SNOBJ increases for each object that is evaluated. "], "extent": [1249, 1442]}, {"type": "para", "indent": 4, "text": ["A good way to guarantee unique object names is to use an expression\n    like ", {"type": "code", "text": ["object_$SNOBJ"]}, "."], "extent": [1442, 1541]}], "container": true}, {"type": "dt", "indent": 0, "text": ["NOBJ"], "extent": [1541, 1547], "body": [{"type": "para", "indent": 4, "text": ["The number of objects that are evaluated by the\n    current node during this timestep. This value is often \n    different from SNOBJ, as many nodes do not process all the objects\n    in a simulation. "], "extent": [1547, 1757]}, {"type": "para", "indent": 4, "text": ["NOBJ may return 0 if the node does not\n    process each object sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group\n    DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [1757, 1884]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJ"], "extent": [1884, 1889], "body": [{"type": "para", "indent": 4, "text": ["The index of the specific object being processed by\n    the node. This value always runs from zero to NOBJ-1 in a given\n    timestep. It does not identify the current object within the\n    simulation like OBJID or OBJNAME; it only identifies the object\u2019s \n    position in the current order of processing. "], "extent": [1889, 2204]}, {"type": "para", "indent": 4, "text": ["This value is useful for generating a\n    random number for each object, or simply splitting the objects into\n    two or more groups to be processed in different ways. This value\n    is -1 if the node does not process objects sequentially (such\n    as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [2204, 2494]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJID"], "extent": [2494, 2501], "body": [{"type": "para", "indent": 4, "text": ["The unique identifier for the object being\n    processed. Every object is assigned an integer value that is unique\n    among all objects in the simulation for all time. Even if an object\n    is deleted, its identifier is never reused. This is very useful in\n    situations where each object needs to be treated differently, for \n    example, to produce a unique random number for each object. "], "extent": [2501, 2900]}, {"type": "para", "indent": 4, "text": ["This value is also the best way to look up information on an object using the dopfield expression function. "], "extent": [2900, 3014]}, {"type": "para", "indent": 4, "text": ["OBJID is -1 if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3014, 3127]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJIDS"], "extent": [3127, 3138], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space-separated list of the unique object\n    identifiers for every object being processed by the current node."], "extent": [3138, 3278]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJNAMES"], "extent": [3278, 3291], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space-separated list of the names of every\n    object being processed by the current node."], "extent": [3291, 3410]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCT"], "extent": [3410, 3417], "body": [{"type": "para", "indent": 4, "text": ["The simulation time (see variable ST) at which the\n    current object was created. "], "extent": [3417, 3510]}, {"type": "para", "indent": 4, "text": ["To check if an object was created\n    on the current timestep, the expression ", {"type": "code", "text": ["$ST == $OBJCT"]}, " should\n    always be used. "], "extent": [3510, 3637]}, {"type": "para", "indent": 4, "text": ["This value is zero if the node does not process\n    objects sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3637, 3757]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCF"], "extent": [3757, 3764], "body": [{"type": "para", "indent": 4, "text": ["The simulation frame (see variable SF) at which the \n    current object was created. It is equivalent to using the \n    dopsttoframe expression on the OBJCT variable. "], "extent": [3764, 3937]}, {"type": "para", "indent": 4, "text": ["This value is zero if the node does not process objects \n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3937, 4058]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJNAME"], "extent": [4058, 4067], "body": [{"type": "para", "indent": 4, "text": ["A string value containing the name of the object being\n    processed. "], "extent": [4067, 4147]}, {"type": "para", "indent": 4, "text": ["Object names are not guaranteed to be unique within a\n    simulation. However, if you name your objects carefully so that they\n    are unique, the object name can be a much easier way to identify an\n    object than the unique object identifier, OBJID. "], "extent": [4147, 4409]}, {"type": "para", "indent": 4, "text": ["The object name can\n    also be used to treat a number of similar objects (with the same\n    name) as a virtual group. If there are 20 objects named ", {"type": "q", "text": ["myobject"]}, ",\n    specifying ", {"type": "code", "text": ["strcmp($OBJNAME, \"myobject\") == 0"]}, " in the activation field\n    of a DOP will cause that DOP to operate on only those 20 objects. "], "extent": [4409, 4721]}, {"type": "para", "indent": 4, "text": ["This value is the empty string if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [4721, 4853]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DOPNET"], "extent": [4853, 4861], "body": [{"type": "para", "indent": 4, "text": ["A string value containing the full path of the current DOP\n    network. This value is most useful in DOP subnet digital assets\n    where you want to know the path to the DOP network that contains the\n    node."], "extent": [4861, 5076]}], "container": true}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [5076, 5082], "body": [{"type": "para", "indent": 4, "text": ["Most dynamics nodes have local variables with the same names as the\n    node\u2019s parameters. For example, in a ", {"scheme": "Node", "value": "/nodes/dop/position", "type": "link", "text": ["Position DOP"], "fullpath": "/nodes/dop/position.html"}, ",\n    you could write the expression:"], "extent": [5082, 5270]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    $tx + 0.1\n    "], "extent": [5270, 5300]}, {"type": "para", "indent": 4, "text": ["\u2026to make the object move 0.1 units along the X axis at each timestep."], "extent": [5300, 5380]}], "container": true}], "container": true, "role": "item_group"}], "text": "Locals"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [3640, 3649], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/femsolidconfigureobject", "type": "link", "text": "", "fullpath": "/nodes/dop/femsolidconfigureobject.html"}], "extent": [3649, 3687]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/solidmodel", "type": "link", "text": "", "fullpath": "/nodes/dop/solidmodel.html"}], "extent": [3687, 3711]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/femsolver", "type": "link", "text": "", "fullpath": "/nodes/dop/femsolver.html"}], "extent": [3711, 3735]}], "container": true}], "text": "Related"}], "title": ["Solid Object"], "summary": ["Creates a Solid Object from SOP Geometry."], "included": ["/nodes/dop/standard_embedding_parms", "/nodes/dop/standard_fem_attribs", "/nodes/dop/standard_locals", "/nodes/dop/standard_objcreation", "/nodes/dop/standard_rbdvolume_parms", "/nodes/dop/standard_softbodydrag_parms", "/nodes/dop/standard_softbodyrest_parms", "/nodes/dop/standard_softbodytarget_parms", "/nodes/dop/standard_solidcollision_parms", "/nodes/dop/standard_solidinitial_parms", "/nodes/dop/standard_solidmodel_parms"]}