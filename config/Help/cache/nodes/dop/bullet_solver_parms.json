{"type": "root", "attrs": {"type": "include"}, "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Time Scale"], "extent": [16, 28], "body": [{"type": "para", "indent": 4, "text": ["The scale value (multiplier) for the time step used by the solver.\n    This can create bullet time-like effects where the physics of the Bullet solver runs at a different rate than the Houdini playbar.\n    A value of 2 causes objects to fall twice as fast, and a value of 0.1 slows them down to a tenth of the speed.\n    This parameter can be animated."], "extent": [47, 405]}], "container": true, "attrs": {"id": "timescale"}}, {"type": "dt", "indent": 0, "text": ["Number of Substeps"], "extent": [405, 425], "body": [{"type": "para", "indent": 4, "text": ["The number of substeps for each simulation step. This is used by Bullet internally. Increasing this number increases the resolution of the simulation."], "extent": [443, 599]}, {"type": "tip_group", "body": [{"ext": null, "type": "tip", "indent": 4, "role": "item", "extent": [599, 609], "body": [{"type": "para", "indent": 8, "text": ["Increasing the number of substeps is one way to fix the problem of collisions not being detected for quickly moving objects."], "extent": [609, 743]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "substeps"}}, {"type": "dt", "indent": 0, "text": ["Sleeping Time"], "extent": [743, 758], "body": [{"type": "para", "indent": 4, "text": ["When an object\u2019s speed has been below its linear and angular speed thresholds for this amount of time, the object is eligible to be deactivated and put to sleep. This can improve performance for simulations where there are some stationary objects."], "extent": [780, 1033]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [1033, 1043], "body": [{"type": "para", "indent": 8, "text": ["An object can only be put to sleep once any nearby objects and objects it is constrained to are also eligible to be put to sleep."], "extent": [1043, 1182]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "sleepingtime"}}, {"type": "dt", "indent": 0, "text": ["Contact Breaking Threshold"], "extent": [1182, 1210], "body": [{"type": "para", "indent": 4, "text": ["Distance threshold used by the Bullet engine when determining whether a cached contact point should be discarded.\n    Adjusting this value according to the scene scale may also improve performance, as it influences the margin added to objects' bounding boxes."], "extent": [1244, 1509]}], "container": true, "attrs": {"id": "contactbreakingthreshold"}}, {"type": "dt", "indent": 0, "text": ["Use Implicit Drag"], "extent": [1509, 1528], "body": [{"type": "para", "indent": 4, "text": ["Applies a more accurate damping for the drag described by the ", {"type": "code", "text": ["targetv"]}, " and ", {"type": "code", "text": ["airresist"]}, " ", {"scheme": "Node", "value": "/nodes/dop/rbdpackedobject#forceattributes", "type": "link", "text": ["point attributes"], "fullpath": "/nodes/dop/rbdpackedobject.html#forceattributes", "fragment": "#forceattributes"}, ", instead of applying it as an explicit force.\n    This also affects how the ", {"type": "code", "text": ["targetw"]}, " and ", {"type": "code", "text": ["spinresist"]}, " attributes are applied for angular drag."], "extent": [1550, 1847]}], "container": true, "attrs": {"id": "implicitdrag"}}, {"type": "dt", "indent": 0, "text": ["Enable Aging"], "extent": [1847, 1861], "body": [{"type": "para", "indent": 4, "text": ["For ", {"scheme": "Node", "value": "/nodes/dop/rbdpackedobject", "type": "link", "text": ["packed objects"], "fullpath": "/nodes/dop/rbdpackedobject.html"}, ", the ", {"type": "code", "text": ["age"]}, " point attribute will be updated for each time step and the objects flagged for deletion if they exceed their ", {"type": "code", "text": ["life"]}, " attribute.\n    For ", {"scheme": "Node", "value": "/nodes/dop/constraintnetwork", "type": "link", "text": ["constraint networks"], "fullpath": "/nodes/dop/constraintnetwork.html"}, ", the ", {"type": "code", "text": ["age"]}, " primitive attribute will be updated for each time step."], "extent": [1876, 2189]}], "container": true, "attrs": {"id": "doage"}}], "container": true}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Constraint Solver"], "extent": [2189, 2213], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Constraint Solver"], "extent": [2213, 2237], "body": [{"type": "para", "indent": 8, "text": ["Specifies which constraint solver Bullet will use to resolve collisions\n        and constraints. Both solvers parallelize the workload, but differ in the\n        strategy they use to do so. ", {"type": "ui", "text": ["Parallel Gauss-Seidel (Islands)"]}, " will be\n        faster in cases that involve many small ", {"type": "q", "text": ["islands"]}, " of interacting objects\n        (for example, a large number of small separate book stacks), whereas\n        ", {"type": "ui", "text": ["Parallel Gauss-Seidel (Graph Coloring)"]}, " should perform better when\n        such ", {"type": "q", "text": ["islands"]}, " are few and large (such as a huge collapsing building)."], "extent": [2271, 2829]}, {"type": "para", "indent": 8, "text": ["Although results obtained with these solvers will generally not be\n        identical, qualitative differences should be minor."], "extent": [2829, 2965]}], "container": true, "attrs": {"id": "constraintsolvertype"}}, {"type": "dt", "indent": 4, "text": ["Constraint Iterations"], "extent": [2965, 2992], "body": [{"type": "para", "indent": 8, "text": ["The number of constraint iterations used by the solver.\n        The more iterations, the more accurate the constraint and collision handling."], "extent": [3018, 3169]}], "container": true, "attrs": {"id": "numiteration"}}, {"type": "dt", "indent": 4, "text": ["Solve Tolerance"], "extent": [3169, 3190], "body": [{"type": "para", "indent": 8, "text": ["Allows the constraint solver to terminate before performing the full number of ", {"type": "ui", "text": ["Constraint Iterations"]}, " if it is close enough to the solution.\n        Larger values can increase performance at the cost of accuracy."], "extent": [3229, 3454]}], "container": true, "attrs": {"id": "constraintsolvertolerance"}}, {"type": "dt", "indent": 4, "text": ["Randomize Constraint Order"], "extent": [3454, 3486], "body": [{"type": "para", "indent": 8, "text": ["Specifies that the constraints should be randomly reordered before each\n        of the ", {"type": "ui", "text": ["Constraint Iterations"]}, ". This may improve stability, but\n        incurs a minor performance hit."], "extent": [3515, 3710]}], "container": true, "attrs": {"id": "randomize_order"}}, {"type": "dt", "indent": 4, "text": ["Ensure Islands are Independent"], "extent": [3710, 3746], "body": [{"type": "para", "indent": 8, "text": ["Specifies that the solver should ensure that changes to an island of interacting objects (including adding, removing, or repositioning objects) do not cause other islands to produce different simulation results, unless those changes cause the objects to interact.\n        Otherwise, the solver only guarantees that resimulating with the exact same input to the solver will produce the same results.\n        Enabling this option may incur a minor performance hit, and may change the simulation results slightly."], "extent": [3784, 4304]}], "container": true, "attrs": {"id": "ensureindependentislands"}}, {"type": "dt", "indent": 4, "text": ["Contact CFM"], "extent": [4304, 4321], "body": [{"type": "para", "indent": 8, "text": ["Increasing the CFM (constraint force mixing) parameter will make\n        contact constraints softer, and may increase the stability of the\n        simulation. Contact constraints may be violated by an amount\n        proportional to this parameter times the force that is needed to\n        enforce the constraint."], "extent": [4344, 4666]}], "container": true, "attrs": {"id": "globalcfm"}}, {"type": "dt", "indent": 4, "text": ["Contact ERP"], "extent": [4666, 4683], "body": [{"type": "para", "indent": 8, "text": ["Specifies what proportion of the constraint error for contact\n        constraints will be fixed during the next simulation step. If ERP\n        (error reduction parameter) is set to ", {"type": "code", "text": ["0"]}, ", constrained objects will drift\n        apart as the simulation proceeds. If ERP is set to ", {"type": "code", "text": ["1"]}, ", the solver will\n        attempt to fix all constraint error during the next simulation step\n        (however, this may result in instability in some situations). A value\n        between 0.1 and 0.8 is recommended for most simulations."], "extent": [4706, 5232]}], "container": true, "attrs": {"id": "globalerp"}}, {"type": "dt", "indent": 4, "text": ["Split Impulse"], "extent": [5232, 5251], "body": [{"type": "para", "indent": 8, "text": ["Tries to make interpenetrating objects split without adding velocity (to keep objects from explosively flying apart)."], "extent": [5277, 5404]}, {"type": "para", "indent": 8, "text": ["Errors when solving positional and velocity constraints can introduce some extra energy to the system.  Although this option removes most of the extra energy, it degenerates quality a little bit, in particular for stable stacking."], "extent": [5404, 5644]}], "container": true, "attrs": {"id": "splitimpulse"}}, {"type": "dt", "indent": 4, "text": ["Penetration Threshold"], "extent": [5644, 5671], "body": [{"type": "para", "indent": 8, "text": [{"type": "ui", "text": ["Split Impulse"]}, " only applies when objects interpenetrate by more than this distance. This number should be negative (representing less than 0 distance between the objects)."], "extent": [5705, 5889]}], "container": true, "attrs": {"id": "penetrationthreshold"}}, {"type": "dt", "indent": 4, "text": ["Split Impulse ERP"], "extent": [5889, 5912], "body": [{"type": "para", "indent": 8, "text": ["Overrides the ", {"type": "ui", "text": ["Error Reduction Parameter"]}, " for contact constraints\n        where the penetration distance is within the ", {"type": "ui", "text": ["Penetration Threshold"]}, "\n        and ", {"type": "ui", "text": ["Split Impulse"]}, " is enabled."], "extent": [5941, 6139]}], "container": true, "attrs": {"id": "splitimpulseerp"}}], "container": true}]}, {"level": 2, "id": "stickycoll", "container": true, "type": "h", "indent": 0, "text": ["Sticky Collisions"], "extent": [6139, 6176], "body": [{"type": "para", "indent": 4, "text": ["If ", {"scheme": null, "value": "/nodes/dop/rbdpackedobject#collisionattributes", "type": "link", "text": ["sticky collisions are turned on for an object"], "fullpath": "/nodes/dop/rbdpackedobject.html#collisionattributes", "fragment": "#collisionattributes"}, ", the solver creates constraints at the instant that a suitable collision occurs, attaching the objects together for the remainder of the timestep.\n    At the end of the timestep, these new constraints are added into a ", {"scheme": "Node", "value": "/nodes/dop/constraintnetwork", "type": "link", "text": ["constraint network\u2019s"], "fullpath": "/nodes/dop/constraintnetwork.html"}, " geometry according to the ", {"type": "ui", "text": ["External Constraint Network"]}, " and ", {"type": "ui", "text": ["Use Internal Constraint Network"]}, " parameters."], "extent": [6176, 6658]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 4, "role": "item", "extent": [6658, 6667], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["newstickycollisions"]}, " primitive group identifies the constraints produced by sticky collisions during the last timestep.\n        This group can be used to configure the properties of new constraints, for example, by using ", {"scheme": "Node", "value": "/nodes/sop/rbdconstraintproperties", "type": "link", "text": "", "fullpath": "/nodes/sop/rbdconstraintproperties.html"}, " in a ", {"scheme": "Node", "value": "/nodes/dop/sopsolver", "type": "link", "text": ["SOP solver"], "fullpath": "/nodes/dop/sopsolver.html"}, ".\n        By default, the new constraints have a ", {"type": "code", "text": ["constraint_name"]}, " attribute with a value of ", {"type": "code", "text": ["Glue"]}, "."], "extent": [6667, 7074]}, {"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["stickycollisions"]}, " primitive group identifies all of the constraints produced by sticky collisions during the simulation."], "extent": [7074, 7209]}], "container": true}, {"type": "tip", "indent": 4, "role": "item", "extent": [7209, 7218], "body": [{"type": "para", "indent": 8, "text": ["The solver creates additional primitive attributes with information about the sticky collision that produced the constraint.\n        The ", {"type": "code", "text": ["collision_depth"]}, " float primitive attribute indicates the penetration depth of the contact point, and ", {"type": "code", "text": ["collision_impulse"]}, " float primitive attribute indicates the impulse that would have been applied to resolve the collision."], "extent": [7218, 7589]}, {"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["collision_pos"]}, ", ", {"type": "code", "text": ["collision_normal"]}, " and ", {"type": "code", "text": ["collision_relvel"]}, " vector primitive attributes contain the contact point\u2019s position, normal and relative velocity, respectively.\n        The ", {"type": "code", "text": ["collision_vel"]}, " vector point attribute contains the velocity at the contact point for each object."], "extent": [7589, 7882]}], "container": true}], "container": true, "role": "item_group"}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["External Constraint Network"], "extent": [7882, 7915], "body": [{"type": "para", "indent": 8, "text": ["Specifies the constraint network where constraints produced by sticky collisions should be emitted.\n        If not specified, the first constraint network encountered by the solver will be used.\n        If no constraint networks exist, sticky collisions will be turned off."], "extent": [7961, 8244]}, {"type": "para", "indent": 8, "text": ["This constraint network must be a ", {"scheme": "Node", "value": "/nodes/dop/applyrel", "type": "link", "text": ["relationship"], "fullpath": "/nodes/dop/applyrel.html"}, " (i.e. ", {"type": "ui", "text": ["Attach Internal Constraints to Object"]}, " is not turned on), and will receive any constraints not added to an internal constraint network by ", {"type": "ui", "text": ["Use Internal Constraint Networks"]}, "."], "extent": [8244, 8505]}], "container": true, "attrs": {"id": "stickyexternalconstraintnetwork"}}, {"type": "dt", "indent": 4, "text": ["Use Internal Constraint Networks"], "extent": [8505, 8543], "body": [{"type": "para", "indent": 8, "text": ["If turned on, the solver will add constraints into the internal constraint network (", {"type": "code", "text": ["ConstraintGeometry"]}, " geometry subdata) for sticky collisions between two objects from the same DOP object.\n        If the DOP object does not have ", {"type": "code", "text": ["ConstraintGeometry"]}, " subdata, the constraint will be added to the ", {"type": "ui", "text": ["External Constraint Network"]}, ".\n        An internal constraint network (", {"type": "code", "text": ["ConstraintGeometry"]}, " subdata) can be added to an object using a ", {"scheme": "Node", "value": "/nodes/dop/constraintnetwork", "type": "link", "text": ["Constraint Network DOP"], "fullpath": "/nodes/dop/constraintnetwork.html"}, " with ", {"type": "ui", "text": ["Attach Internal Constraints to Object"]}, " turned on."], "extent": [8593, 9145]}], "container": true, "attrs": {"id": "stickyuseexternalconstraintnetworks"}}], "container": true}]}]}