{"type": "root", "attrs": {"type": "node", "context": "dop", "internal": "sourceapply", "icon": "DOP/sourceapply", "since": "11.0", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Source Apply"], "extent": [86, 103]}, {"type": "summary", "indent": 0, "text": ["Turns objects into a source for a fluid sim."], "extent": [103, 156]}, {"type": "para", "indent": 0, "text": ["The Source Apply DOP turns DOPs and external objects into sources for the\nattached fluid sim.  It also includes numerous post-processing options to\nmanipulate how the object gets turned into a fluid source."], "extent": [156, 364]}, {"type": "para", "indent": 0, "text": ["There are two ways to use this.  First, it can take a second input.  This is\noften a Static Object which brings in the external object.  The second approach\nis to specify the object in the Non-Wired Sources parameters."], "extent": [364, 584]}, {"type": "para", "indent": 0, "text": ["In all cases, the same processing procedure is used.  First the object is\nturned into a Signed Distance Field (SDF).  Then the SDF is converted to a 0..1\nfog volume storing how much to source each voxel.  This conversion is first\ndone with a lookup from the distance to surface, using the ", {"type": "ui", "text": ["Feathering"]}, " tab.\nThen optional noise can be added.  Finally, point attributes can be multiplied\ninto the value to further mask the emission."], "extent": [584, 1018]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1018, 1030], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Relationship"], "extent": [1030, 1049], "body": [{"type": "para", "indent": 8, "text": ["Despite the name, the Source Apply can also apply other field affects\n        such as pump or sink effects."], "extent": [1049, 1166]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Emission Amount"], "extent": [1166, 1187], "body": [{"type": "para", "indent": 8, "text": ["An overall scale to the source effect."], "extent": [1187, 1235]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Source"], "extent": [1235, 1252], "body": [{"type": "para", "indent": 8, "text": ["The source apply will create a new DOP object to store the computed\n        emission information.  The ", {"type": "ui", "text": ["Source"]}, " tab controls the creation of this\n        object along with the where the SDF comes from."], "extent": [1252, 1466]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Creation Frame Specifies Simulation Frame"], "extent": [16, 59], "body": [{"type": "para", "indent": 4, "text": ["Determines if the creation frame refers to global Houdini\n    frames (", {"type": "code", "text": ["$F"]}, ") or to simulation specific frames (", {"type": "code", "text": ["$SF"]}, ").  The\n    latter is affected by the offset time and scale time at the\n    DOP network level."], "extent": [59, 278]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Creation Frame"], "extent": [278, 294], "body": [{"type": "para", "indent": 4, "text": ["The frame number on which the object will be created. The\n    object is created only when the current frame number is equal to\n    this parameter value. This means the DOP Network must evaluate a\n    timestep at the specified frame, or the object will not be\n    created. "], "extent": [294, 576]}, {"type": "para", "indent": 4, "text": ["For example, if this value is set to 3.5, the\n    ", {"type": "ui", "text": ["Timestep"]}, " parameter of the DOP Network must be changed to\n    ", {"type": "code", "text": ["1/(2*$FPS)"]}, " to ensure the DOP Network has a timestep at frame\n    3.5."], "extent": [576, 772]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number of Objects"], "extent": [772, 791], "body": [{"type": "para", "indent": 4, "text": ["Instead of making a single object, you can create a number of\n    identical objects. You can set each object\u2019s parameters\n    individually by using the ", {"type": "code", "text": ["$OBJID"]}, " expression."], "extent": [791, 973]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Object Name"], "extent": [973, 986], "body": [{"type": "para", "indent": 4, "text": ["The name for the created object. This is the name that shows up\n    in the details view, and is used to reference this object externally. "], "extent": [1007, 1155]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [1155, 1165], "body": [{"type": "para", "indent": 8, "text": ["It is possible to have many objects with the same name, but this complicates writing references, so it is recommended to use something like ", {"type": "code", "text": ["$OBJID"]}, " in the name."], "extent": [1165, 1336]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "object_name"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Solve On Creation Frame"], "extent": [1336, 1361], "body": [{"type": "para", "indent": 4, "text": ["When turned on, newly created objects are solved by the solver on\n    the timestep in which it was created. "], "extent": [1386, 1500]}, {"type": "para", "indent": 4, "text": ["This parameter is usually turned on if this node is creating objects in the middle of a simulation rather than creating objects for the initial state of the simulation."], "extent": [1500, 1674]}], "container": true, "attrs": {"id": "solvefirstframe"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Allow Caching"], "extent": [1674, 1689], "body": [{"type": "para", "indent": 4, "text": ["By preventing a large object from being cached, you can ensure\n    there is enough room in the cache for the previous frames of its\n    collision geometry."], "extent": [1689, 1850]}, {"type": "para", "indent": 4, "text": ["This option should only be set when you are working with a very large sim.\n    It is much better just to use a larger memory cache if possible."], "extent": [1850, 1998]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Source Object List"], "extent": [1506, 1534], "body": [{"type": "para", "indent": 12, "text": ["This is a list of DOP objects in the same simulation that should be\n            used as sources."], "extent": [1534, 1643]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["SOP Path, OBJ Path"], "extent": [1643, 1671], "body": [{"type": "para", "indent": 12, "text": ["Specify geometry to use as the original source."], "extent": [1671, 1732]}, {"type": "para", "indent": 12, "text": ["If this geometry is animating, the ", {"type": "ui", "text": ["Use Deforming Geometry"]}, " must be\n            set in the ", {"type": "ui", "text": ["SDF Generation"]}, " tab."], "extent": [1732, 1861]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Use Object Transform"], "extent": [1861, 1891], "body": [{"type": "para", "indent": 12, "text": ["The transform of the object containing the chosen SOP is\n            applied to the geometry. This is required if there is scaling\n            applied to the source geometry at the object level. "], "extent": [1891, 2099]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Field Reference"], "extent": [2099, 2124], "body": [{"type": "para", "indent": 12, "text": ["To compute the proper grid scaling for the source grids, a path to\n            a fluid object is needed.  The default python expression will find\n            this by searching the first input."], "extent": [2124, 2330]}], "container": true, "role": "item"}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Guides"], "extent": [2330, 2347], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 8, "text": ["Display Geometry"], "extent": [2347, 2382], "body": [{"type": "para", "indent": 12, "text": ["The source geometry can be hidden by turning this off."], "extent": [2382, 2450]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Density"], "extent": [2450, 2467], "body": [{"type": "para", "indent": 12, "text": ["The final density field controlling how much emission occurs in\n            each voxel."], "extent": [2467, 2568]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["SDF"], "extent": [2568, 2581], "body": [{"type": "para", "indent": 12, "text": ["The signed distance field from which the density is computed.\n            Displaying this is useful for determining how the SDF Generation\n            process is working."], "extent": [2581, 2765]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["SDF Generation"], "extent": [2765, 2790], "body": [{"type": "para", "indent": 8, "text": ["This stage takes the source geometry and turns it into an SDF."], "extent": [2790, 2862]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 8, "text": ["Copy SDF Volume from Source Object"], "extent": [2862, 2906], "body": [{"type": "para", "indent": 12, "text": ["If the source is something like a Static Object, it will already\n            have its own SDF generation parameters.  Thus its SDF can be\n            retrieved directly."], "extent": [2906, 3089]}, {"type": "para", "indent": 12, "text": ["If the source is a SOP Path, this controls whether the signed\n            distance field is built in the SOP\u2019s space or in the fluid space.\n            In particular, if one wants to override the number of divisions or\n            use the Proxy Volume, Copy SDF must be set."], "extent": [3089, 3377]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Use Deforming Geometry"], "extent": [3377, 3409], "body": [{"type": "para", "indent": 12, "text": ["If the source is animated, then the SDF has to be rebuilt every\n            frame."], "extent": [3409, 3505]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Build From Particles"], "extent": [3505, 3535], "body": [{"type": "para", "indent": 12, "text": ["Instead of trying to build an SDF, directly write to the\n            fog field from particle points."], "extent": [3535, 3649]}, {"type": "para", "indent": 12, "text": ["NOTE:\n            In this mode feathering is disabled."], "extent": [3649, 3717]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 8, "text": ["Build SDF"], "extent": [3717, 3741], "body": [{"level": 4, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Collisions"], "extent": [16, 33], "body": [{"level": 5, "id": "volume", "container": true, "type": "h", "indent": 0, "text": ["Volume"], "extent": [33, 58], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Use Volume Based Collision Detection"], "extent": [58, 97], "body": [{"type": "para", "indent": 4, "text": ["Turning on this option causes the ", {"scheme": "Node", "value": "/nodes/dop/rbdsolver", "type": "link", "text": ["RBD solver"], "fullpath": "/nodes/dop/rbdsolver.html"}, " to use a volume\n    representation of this object for collision detection. "], "extent": [97, 248]}, {"type": "para", "indent": 4, "text": ["The volume representation results in very fast collision detection\n    and very robust results that are tolerant of temporary\n    interpenetrations. The disadvantage is that a volume\n    representation cannot be used to represent a flat object such as\n    a grid, or a hollow sphere. "], "extent": [248, 542]}, {"type": "para", "indent": 4, "text": ["When this toggle is turned off, the collision detection is geometry-based rather than volume-based. \n    In this case, the collision code will track the trajectories of moving objects over time to find out whether collisions occurred.\n    This allows more accurate results than volume-based collision detection.\n    For this to work, ", {"type": "ui", "text": ["Cache Simulation"]}, " must be enabled on the DOP network."], "extent": [542, 938]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Collision Guide"], "extent": [938, 955], "body": [{"type": "para", "indent": 4, "text": ["The internal representation used for collision detection is\n    converted to visible geometry. This is useful for debugging\n    problems with collision detection."], "extent": [955, 1127]}, {"type": "para", "indent": 4, "text": ["This parameter controls the color of the guide geometry."], "extent": [1127, 1193]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Mode"], "extent": [1193, 1200], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Ray Intersect"], "extent": [1200, 1219], "body": [{"type": "para", "indent": 8, "text": ["Use ray intersection with the geometry to create an\n        accurate volumetric representation of the geometry."], "extent": [1219, 1339]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Meta Balls"], "extent": [1339, 1355], "body": [{"type": "para", "indent": 8, "text": ["Instead of using rays to determine if points are inside or\n        outside, evaluate the metaball field.  "], "extent": [1355, 1479]}, {"type": "para", "indent": 8, "text": ["This should be used\n        with ", {"type": "ui", "text": ["Laser Scanning"]}, " turned off on geometry that consists\n        solely of metaballs."], "extent": [1479, 1605]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Box"], "extent": [1605, 1623], "body": [{"type": "para", "indent": 8, "text": ["Calculate the bounding box for the geometry, and create a volumetric representation that precisely fills that bounding box. This box is always axis aligned in the DOP object\u2019s local space, which is set by the position data."], "extent": [1623, 1864]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [1864, 1878], "body": [{"type": "para", "indent": 12, "text": [{"type": "ui", "text": ["Use Object Transform"]}, " bakes the object transform into the geometry\u2019s transform, leaving the ", {"type": "ui", "text": ["Position Data"]}, " in world space. Turning this off causes the object transform to be send to the ", {"type": "ui", "text": ["Position Data"]}, ", which causes the object\u2019s local space to be reoriented."], "extent": [1878, 2170]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Sphere"], "extent": [2170, 2191], "body": [{"type": "para", "indent": 8, "text": ["Calculate the bounding sphere for the geometry, and create\n        a volumetric representation that precisely fills that\n        bounding sphere."], "extent": [2191, 2345]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Plane"], "extent": [2345, 2365], "body": [{"type": "para", "indent": 8, "text": ["Calculate the bounding box for the geometry, and create a\n        volumetric representation that divides that box along its\n        smallest axis. Everything below that plane is considered\n        inside, and everything above is outside. "], "extent": [2365, 2621]}, {"type": "para", "indent": 8, "text": ["This mode is primarily useful for creating ground planes or immovable\n        walls."], "extent": [2621, 2715]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Minimum"], "extent": [2715, 2728], "body": [{"type": "para", "indent": 8, "text": ["Use the distance to the surface or curve.  If the Offset\n        Surface is 0, no volume will be made.  A positive offset\n        surface will create just that - an offset volume around\n        the object\u2019s surface.  This is useful for turning thin\n        objects or wires into actual solids."], "extent": [2728, 3030]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Volume Sample"], "extent": [3030, 3049], "body": [{"type": "para", "indent": 8, "text": ["The divisions are ignored in this mode, instead they are\n        computed from the first volume or VDB primitive in the geometry.\n        The computed divisions are chosen to match the voxel\n        size of the source volume.\n        The volume primitive is sampled raw and treated as a\n        signed distance field.  The assumption is that the source\n        is the output of an ", {"scheme": "Node", "value": "/nodes/sop/isooffset", "type": "link", "text": ["Iso Offset"], "fullpath": "/nodes/sop/isooffset.html"}, " or\n        ", {"scheme": "Node", "value": "/nodes/sop/vdbfrompolygons", "type": "link", "text": ["VDB From Polygons"], "fullpath": "/nodes/sop/vdbfrompolygons.html"}, " SOP.  If it isn\u2019t a true\n        signed distance fields, unusual things may happen with RBD\n        collisions."], "extent": [3049, 3647]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Division Method"], "extent": [3647, 3664], "body": [{"type": "para", "indent": 4, "text": ["If ", {"type": "ui", "text": ["Non Square"]}, " is chosen, the specified size is divided into the given number\n    of divisions of voxels.  However, the sides of these voxels may not be\n    equal, possibly leading to distorted simulations."], "extent": [3692, 3907]}, {"type": "para", "indent": 4, "text": ["When an axis is specified, that axis is considered authoritative\n    for determining the number of divisions.  The chosen axis' size\n    will be divided by the uniform divisions to yield the voxel\n    size.  The divisions for the other axes will then be adjusted to\n    the closest integer multiple that fits in the required size."], "extent": [3907, 4247]}, {"type": "para", "indent": 4, "text": ["Finally, the size along non-chosen axes will be changed to\n    represent uniform voxel sizes.  If the ", {"type": "ui", "text": ["Max Axis"]}, " option is chosen,\n    the maximum sized axis is used."], "extent": [4247, 4421]}, {"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["By Size"]}, " is chosen, the ", {"type": "ui", "text": ["Division Size"]}, " will be used to\n    compute the number of voxels that fit in the given sized box."], "extent": [4421, 4562]}], "container": true, "attrs": {"id": "sdf_uniformvoxels"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Divisions"], "extent": [4562, 4573], "body": [{"type": "para", "indent": 4, "text": ["Controls the creation of the volumetric representation of this\n    object. This should be set fine enough to capture the desired\n    features of the geometry."], "extent": [4573, 4741]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Uniform Divisions"], "extent": [4741, 4760], "body": [{"type": "para", "indent": 4, "text": ["The resolution of the key axis on the voxel grid.  This allows you\n    to control the overall resolution with one parameter and still\n    preserve uniform voxels.  The ", {"type": "ui", "text": ["Uniform Voxels"]}, " option specifies\n    which axis should be used as the reference. It is usually safest\n    to use the maximum axis."], "extent": [4789, 5100]}], "container": true, "attrs": {"id": "sdf_uniformdiv"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Division Size"], "extent": [5100, 5115], "body": [{"type": "para", "indent": 4, "text": ["The explicit size of the voxels.  The number of voxels will be\n    computed by fitting an integer number of voxels of this size into\n    the given bounds."], "extent": [5115, 5279]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Laser Scan"], "extent": [5279, 5291], "body": [{"type": "para", "indent": 4, "text": ["In laser scan mode the volumetric representation is built by\n    sending rays along the primary axes. Only the closest and\n    farthest intersections are used. The space between these two\n    points is classified as inside, and the rest outside."], "extent": [5291, 5542]}, {"type": "para", "indent": 4, "text": ["The laser scan mode will work even with geometry which has\n    poorly defined normals, self intersects, or is not fully\n    watertight. The disadvantage is that interior features can\u2019t be\n    represented as they are not detected."], "extent": [5542, 5777]}, {"type": "para", "indent": 4, "text": ["When laser scanning is turned off, the volumetric\n    representation is still built by sending rays along the primary\n    axes. All intersections are found, however. Each pair of\n    intersections is tested to see if the segment is inside or\n    outside. This relies on the normal of the geometry being well\n    defined (i.e., manifold, no self intersections), and the\n    geometry being watertight. Complicated shapes with holes can be\n    accurately represented, however."], "extent": [5777, 6256]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fix Signs"], "extent": [6256, 6267], "body": [{"type": "para", "indent": 4, "text": ["Even with the best made geometry, numerical imprecision can\n    result in incorrect sign choices. This option will cause the\n    volumetric representation to be post-processed to look for\n    inconsistent signs. These are then made consistent, usually\n    plugging leaks and filling holes."], "extent": [6267, 6562]}, {"type": "para", "indent": 4, "text": ["This takes time, and can be turned off in cases where the\n    volumetric representation is known to generate without problems."], "extent": [6562, 6694]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Force Bounds"], "extent": [6694, 6708], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "ui", "text": ["Fix Signs"]}, " method alone will smooth out, and usually\n    eliminate, sign inversions. However, it is possible for regions\n    of wrong-sign to become stabilized at the boundary of the\n    volumetric representation. This option will force all voxels on\n    the boundary to be marked as exterior. The ", {"type": "ui", "text": ["Fix Signs"]}, " method\n    will be much less likely to stabilize incorrectly then."], "extent": [6708, 7103]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Invert Sign"], "extent": [7103, 7116], "body": [{"type": "para", "indent": 4, "text": ["If you want a hollow box, one method is to build one box inside\n    the other and not use ", {"type": "ui", "text": ["Laser Scanning"]}, ". A more robust method\n    is to just specify the inner box and use sign inversion. This\n    treats everything outside of the box as inside, allowing the\n    more robust ", {"type": "ui", "text": ["Laser Scanning"]}, " method to be used."], "extent": [7116, 7441]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sign Sweep Threshold"], "extent": [7441, 7463], "body": [{"type": "para", "indent": 4, "text": ["After the fix signs process is complete there can still be\n    inconsistent areas in the SDF.  Large blocks can become\n    stabilized and stick out of the SDF.  A second sign sweep pass\n    can be performed to try to eliminate these blocks."], "extent": [7492, 7738]}, {"type": "para", "indent": 4, "text": ["The sign sweep threshold governs how big of a jump has to\n    occur for a sign transition to be considered inconsistent.  If\n    the values of the sdf change by more than this threshold times\n    the width of the cell, it is considered an invalid sign\n    transition.  The original geometry is then ray intersected to\n    determine inside/outside and the result used to determine\n    which sign is correct.  The correct sign is then propagated\n    forward through the model."], "extent": [7738, 8222]}], "container": true, "attrs": {"id": "sdf_sweepalpha"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Sign Sweep Count"], "extent": [8222, 8244], "body": [{"type": "para", "indent": 4, "text": ["The sign sweeps are repeated until no signs are flipped (ie,\n    all transitions are within the threshold) or this maximum is\n    reached.  Too low of a sign sweep threshold may prevent the\n    process from converging.  Otherwise, it tends to converge very\n    quickly."], "extent": [8273, 8548]}], "container": true, "attrs": {"id": "sdf_sweepcount"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Offset Surface"], "extent": [8548, 8564], "body": [{"type": "para", "indent": 4, "text": ["A constant amount to offset the signed distance field by.\n    This can be used grow the object slightly or shrink it.  Note\n    that it can\u2019t be grown much beyond its original size or it\n    will hit the bounding box of the signed distance field."], "extent": [8564, 8820]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tolerance"], "extent": [8820, 8831], "body": [{"type": "para", "indent": 4, "text": ["This specifies the tolerance used for ray intersections\n    when computing the SDF. This value is multiplied by the size\n    of the geometry and is scale invariant."], "extent": [8853, 9027]}], "container": true, "attrs": {"id": "sdf_tol"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Proxy Volume"], "extent": [9027, 9041], "body": [{"type": "para", "indent": 4, "text": ["The geometry which will be used rather than the base geometry for\n    computing the SDF.  This can be a volume or VDB in the case of Volume Sample\n    mode to allow one better control over the cached data."], "extent": [9041, 9256]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["File Mode"], "extent": [9256, 9267], "body": [{"type": "para", "indent": 4, "text": ["Controls the operation for this object\u2019s volume data."], "extent": [9267, 9326]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Automatic"], "extent": [9326, 9341], "body": [{"type": "para", "indent": 8, "text": ["If a file with the specified name exists already, it is\n        read from disk. Otherwise the volume is created based on the\n        other parameters on this page, and the specified file is\n        created on disk. This file will never be deleted\n        automatically, even when exiting the application."], "extent": [9341, 9654]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Read Files"], "extent": [9654, 9670], "body": [{"type": "para", "indent": 8, "text": ["The specified file is read from disk."], "extent": [9670, 9716]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Write Files"], "extent": [9716, 9733], "body": [{"type": "para", "indent": 8, "text": ["The volume is created using the other parameters on this\n        page, and is then written to the specified file on disk."], "extent": [9733, 9863]}], "container": true}, {"type": "dt", "indent": 4, "text": ["No Operation"], "extent": [9863, 9881], "body": [{"type": "para", "indent": 8, "text": ["The file is never read or written. The parameters on this\n        page are used to create the volume."], "extent": [9881, 9991]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["File"], "extent": [9991, 9997], "body": [{"type": "para", "indent": 4, "text": ["The name of the file to access according to the choice of File\n    Modes above.  This is always .simdata file format.  Saving to\n    a .bgeo extension will ", {"type": "strong", "text": ["not"]}, " save a .bgeo file."], "extent": [9997, 10187]}], "container": true, "role": "item"}], "container": true}]}, {"level": 5, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Surface"], "extent": [10187, 10203], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Surface Representation"], "extent": [10203, 10228], "body": [{"type": "para", "indent": 4, "text": ["Chooses between colliding points against volume or colliding\n    edges against volume. "], "extent": [10228, 10325]}, {"type": "para", "indent": 4, "text": ["Optionally, the point attributes ", {"type": "code", "text": ["nopointvolume"]}, " and ", {"type": "code", "text": ["noedgevolume"]}, " may be added to the geometry to disable individual points/edges from participating in\n    collision detection against a volume object. An edge is disabled\n    if either of its endpoints is disabled."], "extent": [10325, 10601]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Convert To Poly"], "extent": [10601, 10618], "body": [{"type": "para", "indent": 4, "text": ["This enables conversion of primitives (such as spheres) in the\n    geometry into polygons. Only polygons are used for collision\n    detection."], "extent": [10618, 10770]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Triangulate"], "extent": [10770, 10783], "body": [{"type": "para", "indent": 4, "text": ["When this flag is turned on, polygons in the geometry are\n    triangulated."], "extent": [10783, 10868]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["LOD "], "extent": [10868, 10874], "body": [{"type": "para", "indent": 4, "text": ["This controls the Level Of Detail of the triangulation. It is\n    used to specify the point density in the U and V directions."], "extent": [10874, 11010]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Add Barycenters"], "extent": [11010, 11027], "body": [{"type": "para", "indent": 4, "text": ["The barycenters of each polygon can be included in the\n    collision detection as points or edges (connected to the\n    vertices of the primitive)."], "extent": [11027, 11179]}], "container": true, "role": "item"}], "container": true}]}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 8, "text": ["Particle to Field"], "extent": [3789, 3821], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 12, "text": ["Attribute"], "extent": [3821, 3845], "body": [{"type": "para", "indent": 16, "text": ["The particle attribute to accumulate into the source\n                field.  If not enabled, each particle will be treated\n                as having an attribute value of 1.0"], "extent": [3845, 4037]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 12, "text": ["Scale by Voxel Volume"], "extent": [4037, 4072], "body": [{"type": "para", "indent": 16, "text": ["Divide the particle contribution by the voxel volume,\n                thereby normalizing the total added independent of the\n                resolution of the field.  Because volumes are\n                often small, you likely need to reduce emission amount\n                significantly vs not using this option."], "extent": [4072, 4403]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Feathering"], "extent": [4403, 4424], "body": [{"type": "para", "indent": 8, "text": ["After the SDF field is built, it is next converted into the Density\n        field.  Feathering allows you to control the fall-off with distance to\n        surface."], "extent": [4424, 4598]}, {"type": "para", "indent": 8, "text": ["NOTE:\n        Feathering is disabled if ", {"type": "ui", "text": ["Build From Particles"]}, " is enabled."], "extent": [4598, 4684]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 8, "text": ["Treat SDF as Fog"], "extent": [4684, 4711], "body": [{"type": "para", "indent": 12, "text": ["Depending on the Source object, the SDF may not be a proper signed\n            distance field, but already a 0-1 fog volume.  This occurs if\n            sourcing from another smoke sim or from a SOP with a fog volume.\n            In these cases the SDF Generation mode should be set to ", {"type": "ui", "text": ["Volume\n            Sample"]}, " and ", {"type": "ui", "text": ["Treat SDF as Fog"]}, " turned on to avoid the feathering look\n            up pass."], "extent": [4711, 5125]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Hollow Interior"], "extent": [5125, 5150], "body": [{"type": "para", "indent": 12, "text": ["By default, any voxels inside the volume are marked as full\n            emitters.  However, if you want a emit-from-surface effect, you can\n            add a fall off curve for the interior as well."], "extent": [5150, 5362]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Distance, Feather"], "extent": [5362, 5389], "body": [{"type": "para", "indent": 12, "text": ["The distance is the length of the fall off curve.  The feather\n            curve is how the density will fall off with distance to the\n            surface.  The left is the surface, the right the farthest from the\n            surface."], "extent": [5389, 5637]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Noise"], "extent": [5637, 5653], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 8, "text": ["Add Noise"], "extent": [5653, 5672], "body": [{"type": "para", "indent": 12, "text": ["Noise will multiply the source field with a noise field.  This\n            will turn the solid object into a Swiss cheese like object, often\n            resulting in nicer chaotic behavior."], "extent": [5672, 5875]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Amount"], "extent": [5875, 5891], "body": [{"type": "para", "indent": 12, "text": ["How much to mix the result of this calculation with the\n            original source.  A value of 0 is the same as not adding\n            noise, 0.5 will blend 50% of each, and 1 will use the remapped\n            noise value as the final source value."], "extent": [5891, 6155]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Frequency-Flow Roughness"], "extent": [6155, 6189], "body": [{"type": "para", "indent": 12, "text": ["These control an anti-aliased flow noise VOP."], "extent": [6189, 6248]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Amplitude"], "extent": [6248, 6267], "body": [{"type": "para", "indent": 12, "text": ["How harsh the transition from 0 to 1 should be.  A high\n            contrast results in a sharp boundary between the kept and\n            discarded regions, a low contrast results in a smoother drop\n            off."], "extent": [6267, 6496]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Remap Noise"], "extent": [6496, 6517], "body": [{"type": "para", "indent": 12, "text": ["Remaps the source value.  This allows remapping the fall-off\n            of the transition from sourced to non-sourced voxels.\n            Alternately, by building a hill shaped ramp, one can extract\n            a contour of the source shape rather than a solid version."], "extent": [6517, 6801]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Attribute"], "extent": [6801, 6821], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 8, "text": ["Multiply by Attribute"], "extent": [6821, 6861], "body": [{"type": "para", "indent": 12, "text": ["Finally, the computed density can be multiplied by a point\n            attribute.  The closest points are used for the mapping\n            computation.  Combined with the Paint SOP, this allows\n            the easy painting of emission regions."], "extent": [6861, 7118]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Attribute"], "extent": [7118, 7137], "body": [{"type": "para", "indent": 12, "text": ["Name of the float point attribute to use for scaling."], "extent": [7137, 7203]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Max Extrapolation"], "extent": [7203, 7230], "body": [{"type": "para", "indent": 12, "text": ["Voxels farther than this from the closest point will be zeroed,\n            rather than using the closest point value.  This can be important\n            for efficiency for large number of points or sparse volumes."], "extent": [7230, 7458]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Physical"], "extent": [7458, 7477], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 8, "text": ["Temperature"], "extent": [7477, 7499], "body": [{"type": "para", "indent": 12, "text": ["The effective temperature of this object for sourcing."], "extent": [7499, 7567]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 8, "text": ["Override Velocity"], "extent": [7567, 7594], "body": [{"type": "para", "indent": 12, "text": ["Sets the source to an explicit velocity."], "extent": [7594, 7648]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [7648, 7658], "body": [{"type": "para", "indent": 8, "text": ["The velocity value should be used if the ", {"type": "ui", "text": ["Velocity Type"]}, " on the ", {"type": "ui", "text": ["Sources"]}, " tab of the ", {"scheme": "Node", "value": "/nodes/dop/fluidsolver", "type": "link", "text": ["Fluid Solver"], "fullpath": "/nodes/dop/fluidsolver.html"}, " is set to use ", {"type": "ui", "text": ["Point Velocity"]}, "."], "extent": [7658, 7830]}, {"type": "para", "indent": 8, "text": ["If there isn\u2019t a ", {"type": "code", "text": ["v"]}, " attribute present, it is computed by differing frames. If ", {"type": "code", "text": ["v"]}, " is present, it overrides the previous frame. You can add a ", {"type": "code", "text": ["v"]}, " attribute to any source type, and it will use the ", {"type": "code", "text": ["v"]}, " attribute rather than the point deltas."], "extent": [7830, 8079]}], "container": true}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "outputs", "container": true, "type": "outputs_section", "indent": 0, "role": "section", "extent": [8079, 8088], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["First"], "extent": [8088, 8099], "body": [{"type": "para", "indent": 8, "text": ["The fluid object to add a source to."], "extent": [8099, 8144]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Second"], "extent": [8144, 8156], "body": [{"type": "para", "indent": 8, "text": ["An optional DOP object to use as a source."], "extent": [8156, 8208]}], "container": true}], "container": true}], "text": "Outputs"}, {"level": 1, "id": "locals", "container": true, "type": "locals_section", "indent": 0, "role": "section", "extent": [8208, 8216], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["ST"], "extent": [16, 20], "body": [{"type": "para", "indent": 4, "text": ["The simulation time for which the node is being evaluated. "], "extent": [20, 89]}, {"type": "para", "indent": 4, "text": ["Depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP Network"], "fullpath": "/nodes/obj/dopnet.html"}, " \n    ", {"type": "ui", "text": ["Offset Time"]}, " and ", {"type": "ui", "text": ["Scale Time"]}, " parameters, \n    this value may not be equal to the current Houdini time\n    represented by the variable T. "], "extent": [89, 310]}, {"type": "para", "indent": 4, "text": ["ST is guaranteed to have a value of zero at the\n    start of a simulation, so when testing for the first timestep of a\n    simulation, it is best to use a test like ", {"type": "code", "text": ["$ST == 0"]}, ", rather than\n    ", {"type": "code", "text": ["$T == 0"]}, " or ", {"type": "code", "text": ["$FF == 1"]}, "."], "extent": [310, 533]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SF"], "extent": [533, 537], "body": [{"type": "para", "indent": 4, "text": ["The simulation frame (or more accurately, the \n    simulation time step number) for which the node is being evaluated."], "extent": [537, 665]}, {"type": "para", "indent": 4, "text": ["Depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP Network"], "fullpath": "/nodes/obj/dopnet.html"}, " parameters, \n    this value may not be equal to the current Houdini frame number\n    represented by the variable F. Instead, it is equal to\n    the simulation time (ST) divided by the simulation timestep size \n    (TIMESTEP)."], "extent": [665, 959]}], "container": true}, {"type": "dt", "indent": 0, "text": ["TIMESTEP"], "extent": [959, 969], "body": [{"type": "para", "indent": 4, "text": ["The size of a simulation timestep. This value is\n    useful for scaling values that are expressed in units per second, but\n    are applied on each timestep."], "extent": [969, 1131]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SFPS"], "extent": [1131, 1137], "body": [{"type": "para", "indent": 4, "text": ["The inverse of the TIMESTEP value. It is the number\n    of timesteps per second of simulation time."], "extent": [1137, 1242]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SNOBJ"], "extent": [1242, 1249], "body": [{"type": "para", "indent": 4, "text": ["The number of objects in the simulation. For nodes that\n    create objects such as the ", {"scheme": "Node", "value": "/nodes/dop/emptyobject", "type": "link", "text": ["Empty Object DOP"], "fullpath": "/nodes/dop/emptyobject.html"}, ",\n    SNOBJ increases for each object that is evaluated. "], "extent": [1249, 1442]}, {"type": "para", "indent": 4, "text": ["A good way to guarantee unique object names is to use an expression\n    like ", {"type": "code", "text": ["object_$SNOBJ"]}, "."], "extent": [1442, 1541]}], "container": true}, {"type": "dt", "indent": 0, "text": ["NOBJ"], "extent": [1541, 1547], "body": [{"type": "para", "indent": 4, "text": ["The number of objects that are evaluated by the\n    current node during this timestep. This value is often \n    different from SNOBJ, as many nodes do not process all the objects\n    in a simulation. "], "extent": [1547, 1757]}, {"type": "para", "indent": 4, "text": ["NOBJ may return 0 if the node does not\n    process each object sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group\n    DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [1757, 1884]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJ"], "extent": [1884, 1889], "body": [{"type": "para", "indent": 4, "text": ["The index of the specific object being processed by\n    the node. This value always runs from zero to NOBJ-1 in a given\n    timestep. It does not identify the current object within the\n    simulation like OBJID or OBJNAME; it only identifies the object\u2019s \n    position in the current order of processing. "], "extent": [1889, 2204]}, {"type": "para", "indent": 4, "text": ["This value is useful for generating a\n    random number for each object, or simply splitting the objects into\n    two or more groups to be processed in different ways. This value\n    is -1 if the node does not process objects sequentially (such\n    as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [2204, 2494]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJID"], "extent": [2494, 2501], "body": [{"type": "para", "indent": 4, "text": ["The unique identifier for the object being\n    processed. Every object is assigned an integer value that is unique\n    among all objects in the simulation for all time. Even if an object\n    is deleted, its identifier is never reused. This is very useful in\n    situations where each object needs to be treated differently, for \n    example, to produce a unique random number for each object. "], "extent": [2501, 2900]}, {"type": "para", "indent": 4, "text": ["This value is also the best way to look up information on an object using the dopfield expression function. "], "extent": [2900, 3014]}, {"type": "para", "indent": 4, "text": ["OBJID is -1 if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3014, 3127]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJIDS"], "extent": [3127, 3138], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space-separated list of the unique object\n    identifiers for every object being processed by the current node."], "extent": [3138, 3278]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJNAMES"], "extent": [3278, 3291], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space-separated list of the names of every\n    object being processed by the current node."], "extent": [3291, 3410]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCT"], "extent": [3410, 3417], "body": [{"type": "para", "indent": 4, "text": ["The simulation time (see variable ST) at which the\n    current object was created. "], "extent": [3417, 3510]}, {"type": "para", "indent": 4, "text": ["To check if an object was created\n    on the current timestep, the expression ", {"type": "code", "text": ["$ST == $OBJCT"]}, " should\n    always be used. "], "extent": [3510, 3637]}, {"type": "para", "indent": 4, "text": ["This value is zero if the node does not process\n    objects sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3637, 3757]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCF"], "extent": [3757, 3764], "body": [{"type": "para", "indent": 4, "text": ["The simulation frame (see variable SF) at which the \n    current object was created. It is equivalent to using the \n    dopsttoframe expression on the OBJCT variable. "], "extent": [3764, 3937]}, {"type": "para", "indent": 4, "text": ["This value is zero if the node does not process objects \n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3937, 4058]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJNAME"], "extent": [4058, 4067], "body": [{"type": "para", "indent": 4, "text": ["A string value containing the name of the object being\n    processed. "], "extent": [4067, 4147]}, {"type": "para", "indent": 4, "text": ["Object names are not guaranteed to be unique within a\n    simulation. However, if you name your objects carefully so that they\n    are unique, the object name can be a much easier way to identify an\n    object than the unique object identifier, OBJID. "], "extent": [4147, 4409]}, {"type": "para", "indent": 4, "text": ["The object name can\n    also be used to treat a number of similar objects (with the same\n    name) as a virtual group. If there are 20 objects named ", {"type": "q", "text": ["myobject"]}, ",\n    specifying ", {"type": "code", "text": ["strcmp($OBJNAME, \"myobject\") == 0"]}, " in the activation field\n    of a DOP will cause that DOP to operate on only those 20 objects. "], "extent": [4409, 4721]}, {"type": "para", "indent": 4, "text": ["This value is the empty string if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [4721, 4853]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DOPNET"], "extent": [4853, 4861], "body": [{"type": "para", "indent": 4, "text": ["A string value containing the full path of the current DOP\n    network. This value is most useful in DOP subnet digital assets\n    where you want to know the path to the DOP network that contains the\n    node."], "extent": [4861, 5076]}], "container": true}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [5076, 5082], "body": [{"type": "para", "indent": 4, "text": ["Most dynamics nodes have local variables with the same names as the\n    node\u2019s parameters. For example, in a ", {"scheme": "Node", "value": "/nodes/dop/position", "type": "link", "text": ["Position DOP"], "fullpath": "/nodes/dop/position.html"}, ",\n    you could write the expression:"], "extent": [5082, 5270]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    $tx + 0.1\n    "], "extent": [5270, 5300]}, {"type": "para", "indent": 4, "text": ["\u2026to make the object move 0.1 units along the X axis at each timestep."], "extent": [5300, 5380]}], "container": true}], "container": true, "role": "item_group"}], "text": "Locals"}], "title": ["Source Apply"], "summary": ["Turns objects into a source for a fluid sim."], "included": ["/nodes/dop/standard_locals", "/nodes/dop/standard_objcreation", "/nodes/dop/standard_rbdvolume_parms"]}