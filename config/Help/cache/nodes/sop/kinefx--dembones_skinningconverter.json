{"type": "root", "attrs": {"type": "node", "context": "sop", "namespace": "kinefx", "internal": "dembones_skinningconverter", "icon": "SOP/kinefx-dembones_skinningconverter", "tags": "animation", "since": "20", "version": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Dem Bones Skinning Converter"], "extent": [157, 190]}, {"type": "summary", "indent": 0, "text": ["Generates and assigns capture weights to points based on the Smooth Skinning Decomposition with Rigid Bones algorithm."], "extent": [190, 317]}, {"type": "para", "indent": 0, "text": ["Dem Bones - \u00a9 Electronic Arts 2019"], "extent": [317, 353]}, {"type": "para", "indent": 0, "text": ["This node creates captures weights on geometry that is to be deformed by the ", {"scheme": "Node", "value": "/nodes/sop/bonedeform", "type": "link", "text": ["Bone Deform SOP"], "fullpath": "/nodes/sop/bonedeform.html"}, ". The capture weights are computed using an implementation of ", {"type": "em", "text": ["Smooth Skinning Decomposition with Rigid Bones"]}, ", \nan automated algorithm that extracts the Linear Blend Skinning (LBS) with bone transformations from a set of example meshes."], "extent": [353, 706]}, {"type": "para", "indent": 0, "text": ["Skinning decomposition can be used in various tasks:"], "extent": [706, 760]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Converting any animated mesh sequence. For example, geometry cache to LBS, which can then be played back in popular game engines."], "extent": [760, 893]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Solving skin weights from shapes and skeleton poses. For example, converting blend shapes to LBS."], "extent": [893, 994]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Solving bone transformations for a mesh animation by providing skin weights."], "extent": [994, 1074]}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [1074, 1080], "body": [{"type": "para", "indent": 4, "text": ["This node can only handle clean input data, for example, only one piece of connected geometry. If this node takes a really long time to process, it may have gotten stuck while trying to find a solution. To fix this, set the ", {"type": "ui", "text": ["Min Non-Zero Weights"]}, " parameter to 1."], "extent": [1080, 1350]}], "container": true}], "container": true, "role": "item_group"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1350, 1362], "body": [{"level": 3, "type": "sep", "indent": 0, "text": [" Conversion Settings "], "extent": [1362, 1391], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Input Animated Cache"], "extent": [1391, 1418], "body": [{"type": "para", "indent": 8, "text": ["The path to the Alembic geometry cache that contains the animated mesh sequence used to compute skinning weights."], "extent": [1447, 1570]}], "container": true, "attrs": {"id": "sAnimatedCache"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}, {"level": 3, "type": "sep", "indent": 0, "text": [" Bones "], "extent": [1570, 1584], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Max Number of Bones"], "extent": [1584, 1610], "body": [{"type": "para", "indent": 8, "text": ["The maximum number of bones that can be generated. "], "extent": [1631, 1692]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [1692, 1706], "body": [{"type": "para", "indent": 12, "text": ["Due to the possibility that more efficient solutions may be found during conversion, the actual output may be lower than the number specified by this parameter."], "extent": [1706, 1880]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "nBones"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}, {"level": 3, "type": "sep", "indent": 0, "text": [" Solve Iterations "], "extent": [1880, 1905], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Global Iterations"], "extent": [1905, 1933], "body": [{"type": "para", "indent": 8, "text": ["The number of global iterations to process during the conversion. This functions as a scalar for the number of optimizations that have to be calculated. For more complex scenes, increase this value. "], "extent": [1954, 2163]}], "container": true, "attrs": {"id": "nIters"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Error Tolerance"], "extent": [2163, 2184], "body": [{"type": "para", "indent": 8, "text": ["The algorithm keeps track of the decreasing errors during iterations, and increments a counter if the reduction is less than the threshold specified by this parameter. This allows the algorithm to stop optimizing early if no improvement is found after the number of iterations specified by the ", {"type": "ui", "text": ["Patience"]}, " parameter."], "extent": [2208, 2535]}], "container": true, "attrs": {"id": "tolerance"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Patience"], "extent": [2535, 2549], "body": [{"type": "para", "indent": 8, "text": ["The number of iterations to wait before stopping early when no improvement is found that is incrementally better than the threshold specified by the ", {"type": "ui", "text": ["Error Tolerance"]}, " parameter."], "extent": [2572, 2761]}], "container": true, "attrs": {"id": "patience"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Splitting Iterations"], "extent": [2761, 2787], "body": [{"type": "para", "indent": 8, "text": ["The number of clustering update iterations that are applied on initialization. "], "extent": [2812, 2901]}], "container": true, "attrs": {"id": "nInitIters"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Transform Iterations"], "extent": [2901, 2927], "body": [{"type": "para", "indent": 8, "text": ["The number of bone transformation update iterations per global iteration. Dem Bones performs multiple bone transform updates after each update on the weights."], "extent": [2953, 3121]}], "container": true, "attrs": {"id": "nTransIters"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}, {"level": 3, "type": "sep", "indent": 0, "text": [" Soft Constraints "], "extent": [3121, 3146], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Translations Affinity"], "extent": [3146, 3174], "body": [{"type": "para", "indent": 8, "text": ["Activates a soft constraint that forces bone translation that follows the centroid of the patch supported by that bone. Values greater than 0 turn on the soft constraint, and values less than 0 turn off the soft constraint."], "extent": [3200, 3433]}, {"type": "para", "indent": 8, "text": ["For many use cases, a value of 0 (no constraint) may be required. Whether or not to use higher values should depend on numerical stability and whether optimization can converge or not."], "extent": [3433, 3627]}], "container": true, "attrs": {"id": "transAffine"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["P-Norm"], "extent": [3627, 3639], "body": [{"type": "para", "indent": 8, "text": ["The power used to compute the centroid of the patch. Higher values move the centroid of the bones closer to the vertices with max weights (soft-max)."], "extent": [3669, 3828]}], "container": true, "attrs": {"id": "transAffineNorm"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}, {"level": 3, "type": "sep", "indent": 0, "text": [" Weights "], "extent": [3828, 3844], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Weights Iterations"], "extent": [3844, 3869], "body": [{"type": "para", "indent": 8, "text": ["The number of weight updates to perform after each bone update. 1-5 iterations usually produce good results. These iterations are very expensive, so it is better to increase the ", {"type": "ui", "text": ["Global Iterations"]}, " than to increase the number of ", {"type": "ui", "text": ["Weights Iterations"]}, "."], "extent": [3897, 4161]}], "container": true, "attrs": {"id": "nWeightsIters"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Smoothness"], "extent": [4161, 4177], "body": [{"type": "para", "indent": 8, "text": ["Controls the weights smoothness for the generated soft constraint. "], "extent": [4205, 4282]}], "container": true, "attrs": {"id": "weightsSmooth"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Step Size"], "extent": [4282, 4297], "body": [{"type": "para", "indent": 8, "text": ["The step size of the Implicit Laplacian smoothing on the weights for the soft constraint."], "extent": [4329, 4428]}], "container": true, "attrs": {"id": "weightsSmoothStep"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Min Non-Zero Weights"], "extent": [4428, 4454], "body": [{"type": "para", "indent": 8, "text": ["The number of non-zero weights per vertex required for the conversion to succeed."], "extent": [4472, 4563]}], "container": true, "attrs": {"id": "nnz"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}], "text": "Parameters"}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [4563, 4571], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Rest Geometry"], "extent": [4571, 4587], "body": [{"type": "para", "indent": 4, "text": ["The geometry to capture. The geometry must be closed."], "extent": [4587, 4646]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Capture Geometry"], "extent": [4646, 4664], "body": [{"type": "para", "indent": 4, "text": ["The SOP skeleton to capture the Rest Geometry input to."], "extent": [4664, 4725]}], "container": true}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "outputs", "container": true, "type": "outputs_section", "indent": 0, "role": "section", "extent": [4725, 4734], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Rest Geometry"], "extent": [4734, 4750], "body": [{"type": "para", "indent": 4, "text": ["The skin geometry with capture attributes (", {"type": "code", "text": ["boneCapture"]}, " point\n    attribute)."], "extent": [4750, 4834]}], "container": true}], "container": true}], "text": "Outputs"}, {"level": 1, "id": "attributes", "container": true, "type": "attributes_section", "indent": 0, "role": "section", "extent": [4834, 4846], "body": [{"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": ["boneCapture"], "extent": [4846, 4860], "body": [{"type": "para", "indent": 4, "text": ["Attribute added to the Rest Geometry output that defines the skinning\n    weights for the deformation, ready for use with the ", {"scheme": "Node", "value": "/nodes/sop/kinefx--jointdeform", "type": "link", "text": ["Joint Deform SOP"], "fullpath": "/nodes/sop/kinefx--jointdeform.html"}, "."], "extent": [4860, 5040]}], "container": true, "role": "item", "id": "bonecapture"}], "container": true, "role": "item_group"}], "text": "Attributes"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [5040, 5049], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/kinefx--jointdeform", "type": "link", "text": "", "fullpath": "/nodes/sop/kinefx--jointdeform.html"}], "extent": [5049, 5082]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/agent", "type": "link", "text": "", "fullpath": "/nodes/sop/agent.html"}], "extent": [5082, 5101]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "/crowds/agents", "type": "link", "text": ["Agent Primitives"], "fullpath": "/crowds/agents.html"}], "extent": [5101, 5137]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "/character/kinefx/importcharacters", "type": "link", "text": ["Bringing animation and character data into KineFX"], "fullpath": "/character/kinefx/importcharacters.html"}], "extent": [5137, 5226]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "/character/kinefx/exportcharacters", "type": "link", "text": ["Getting animation and character data out of KineFX"], "fullpath": "/character/kinefx/exportcharacters.html"}], "extent": [5226, 5316]}], "container": true}], "text": "Related"}], "title": ["Dem Bones Skinning Converter"], "summary": ["Generates and assigns capture weights to points based on the Smooth Skinning Decomposition with Rigid Bones algorithm."]}