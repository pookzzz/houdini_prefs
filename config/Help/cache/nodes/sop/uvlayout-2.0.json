{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "uvlayout", "icon": "SOP/uvlayout", "tags": "uvs, textures, cleanup", "version": "2.0", "since": "16.5", "verb_since": "16.5", "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["UV Layout"], "extent": [0, 14]}, {"type": "summary", "indent": 0, "text": ["Tries to pack UV islands efficiently into a limited area."], "extent": [157, 222]}, {"type": "para", "indent": 0, "text": ["UV Layout produces a packing that tries to minimize the wasted UV area. This is achieved by translating and uniform scaling of the UV islands. The result is a non-overlapping placement of all islands into one or several UV tiles according to the ", {"type": "ui", "text": ["Packing Method"]}, ". The input geometry should have a valid vertex UV attribute. UV Layout uses this attribute to rewrite the UVs."], "extent": [222, 599]}, {"type": "vimeo_group", "body": [{"ext": null, "type": "vimeo", "indent": 0, "text": ["UV layout"], "role": "item", "extent": [599, 616], "body": [], "container": true, "attrs": {"id": "116671421"}}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["The node\u2019s packing algorithm is very good at finding good layouts, however you should keep a few things in mind:"], "extent": [636, 750]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["There is a theoretical limit to the amount of packing it can do in a square. For example, if you're packing two equal sized square islands into a square tile, the algorithm can\u2019t achieve more than 50% coverage."], "extent": [750, 964]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Packing is a hard problem for computers, which the node can only solve by trying different sizes and orientations and seeing if they fit."], "extent": [964, 1105]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Increasing iterations ", {"type": "em", "text": ["might"]}, " eventually find a better solution than the initial (iterations=1) packing, and often will, but it might not. The only way to know is to try increasing the iterations and waiting for the result. Unfortunately, when looking at a given packing, there\u2019s not even a way of knowing how much room there is for improvement."], "extent": [1105, 1454]}], "container": true}, {"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 0, "role": "item", "extent": [1454, 1460], "body": [{"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/nodes/sop/uvlayout_after.jpg", "type": "img", "text": ""}], "extent": [1460, 1509]}], "container": true}, {"ext": null, "type": "col", "indent": 0, "role": "item", "extent": [1509, 1515], "body": [{"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/nodes/sop/uvlayout_detail.jpg", "type": "img", "text": ""}], "extent": [1515, 1566]}], "container": true}], "container": true, "role": "item_group"}, {"type": "tip_group", "body": [{"type": "tip", "indent": 0, "role": "item", "extent": [1566, 1571], "body": [{"type": "para", "indent": 4, "text": ["If you have ", {"type": "q", "text": ["Descriptive Parameter"]}, " text badges on in the network editor (", {"type": "ui", "text": ["View \u25b8 Display Options"]}, ", ", {"type": "ui", "text": ["Text Badges"]}, " tab), the node displays the current coverage percentage (for packing methods where that makes sense)."], "extent": [1571, 1797]}], "container": true}], "container": true, "role": "item_group"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1797, 1809], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["UV Attribute"], "extent": [1809, 1824], "body": [{"type": "para", "indent": 4, "text": ["The name of the texture coordinate attribute to lay out, defaulting to ", {"type": "code", "text": ["uv"]}, "."], "extent": [1841, 1923]}], "container": true, "attrs": {"id": "uvattr"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Group"], "extent": [1923, 1930], "body": [{"type": "para", "indent": 4, "text": ["Only pack UVs for polygons in this group. If this is blank, pack UVs for all polygons."], "extent": [1950, 2042]}], "container": true, "attrs": {"id": "group"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Pack Between Non-group Islands"], "extent": [2042, 2074], "body": [{"type": "para", "indent": 4, "text": ["When this is on, the node tries to pack the islands selected in the ", {"type": "ui", "text": ["Group"]}, " field in-between any other islands that might exist in the same tile. When this is off, the node ignores any other islands and just lays out the selected islands over them."], "extent": [2100, 2356]}], "container": true, "attrs": {"id": "packbetween"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Additional Seams"], "extent": [2356, 2374], "body": [{"type": "para", "indent": 4, "text": ["The node determines ", {"type": "q", "text": ["island"]}, " connectivity by points with the same UV values (within the ", {"type": "ui", "text": ["Connectivity tolerance"]}, " value). If you specify an edge group in this parameter, the group\u2019s edges are split apart in the UV islands. This allows you to break up large UV islands, potentially allowing "], "extent": [2404, 2706]}], "container": true, "attrs": {"id": "additionalseams"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Packing style "], "extent": [2706, 2728]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Packing Method"], "extent": [2728, 2745], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Single Tile"], "extent": [2767, 2784], "body": [{"type": "para", "indent": 8, "text": ["Packs all islands into a single tile (by default, the unit square (", {"type": "code", "text": ["0,0"]}, " to ", {"type": "code", "text": ["1,1"]}, ")). You can use the ", {"type": "ui", "text": ["Center"]}, " and ", {"type": "ui", "text": ["Size"]}, " parameters to change the tile to pack into."], "extent": [2784, 2966]}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/uv/uvlayout1.jpg", "type": "img", "text": ""}], "extent": [2966, 3008]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Fixed Scale"], "extent": [3008, 3025], "body": [{"type": "para", "indent": 8, "text": ["Packs all islands, scaled by the ", {"type": "ui", "text": ["Scale"]}, " parameter, into as few tiles as possible."], "extent": [3025, 3131]}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/uv/uvlayout2.jpg", "type": "img", "text": ""}], "extent": [3131, 3173]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["udim"]}, " Attribute"], "extent": [3173, 3195], "body": [{"type": "para", "indent": 8, "text": ["Packs islands into individual tiles based on the ", {"type": "code", "text": ["udim"]}, " attribute. Islands are packed into a tile numbered with the value of the ", {"type": "code", "text": ["udim"]}, " attribute. Valid ", {"type": "code", "text": ["udim"]}, " values start at ", {"type": "code", "text": ["1000"]}, "."], "extent": [3195, 3392]}, {"type": "para", "indent": 8, "text": ["It is enough for one polygon in an island to have a valid ", {"type": "code", "text": ["udim"]}, " number for the island to be packed into the tile with that number. If multiple polygons in an island have valid ", {"type": "code", "text": ["udim"]}, " numbers, the nodes uses the smallest of these numbers. "], "extent": [3392, 3649]}, {"type": "para", "indent": 8, "text": ["Islands with invalid ", {"type": "code", "text": ["udim"]}, " values are assumed to have ", {"type": "code", "text": ["udim"]}, " of 1000 and are placed into the first tile (", {"type": "code", "text": ["0,0"]}, " to ", {"type": "code", "text": ["1,1"]}, ")."], "extent": [3649, 3781]}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/uv/uvlayout3.jpg", "type": "img", "text": ""}, "    "], "extent": [3781, 3827]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Current Tile"], "extent": [3827, 3845], "body": [{"type": "para", "indent": 8, "text": ["Groups the islands into the tile they currently occupy (based on the island\u2019s top-left most vertex)."], "extent": [3845, 3955]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "packing"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Padding"], "extent": [3955, 3964], "body": [{"type": "para", "indent": 4, "text": ["Indicates the distance between distinct islands, measured in 1/1000 of the\n    frame length."], "extent": [3982, 4080]}], "container": true, "attrs": {"id": "padding"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Apply Padding to Tile Boundaries"], "extent": [4080, 4114], "body": [{"type": "para", "indent": 4, "text": ["Indicates whether the padding should be also applied to the frame \n    boundaries."], "extent": [4140, 4228]}], "container": true, "attrs": {"id": "paddingboundary"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Pack Islands in Cavities"], "extent": [4228, 4254], "body": [{"type": "para", "indent": 4, "text": ["If islands have ", {"type": "q", "text": ["holes"]}, " of unused texture space, pack other smaller islands into them."], "extent": [4283, 4375]}], "container": true, "attrs": {"id": "packincavities"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Center"], "extent": [4375, 4383], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Packing method"]}, " is ", {"type": "q", "text": ["Single tile"]}, ", sets the center of the tile to pack into. The default is ", {"type": "code", "text": ["0.5,0.5"]}, ", centering the tile on the unit square (", {"type": "code", "text": ["0,0"]}, " to ", {"type": "code", "text": ["1,1"]}, ")."], "extent": [4408, 4579]}], "container": true, "attrs": {"id": "bboxcenter"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Size"], "extent": [4579, 4585], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Packing method"]}, " is ", {"type": "q", "text": ["Single tile"]}, ", sets the size of the tile to pack into. The default is one unit by one unit."], "extent": [4608, 4733]}], "container": true, "attrs": {"id": "bboxsize"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Island transformations "], "extent": [4733, 4764]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Scale"], "extent": [4764, 4772], "body": [{"type": "para", "indent": 4, "text": ["The scale parameter for the second packing method."], "extent": [4788, 4844]}], "container": true, "attrs": {"id": "scale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Correct Island Area Proportions"], "extent": [4844, 4877], "body": [{"type": "para", "indent": 4, "text": ["Resizes the islands before packing (maintaining their combined area) so that the relative areas of any two islands is the same as their corresponding surface areas on the 3D mesh. "], "extent": [4904, 5094]}], "container": true, "attrs": {"id": "correctareas"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Axis Align Islands"], "extent": [5094, 5114], "body": [{"type": "para", "indent": 4, "text": ["Performs a computation of the oriented bounding boxes for each UV island and uses the information to axis align each island. This should produce much better packing results, especially for rectangular geometry."], "extent": [5145, 5362]}], "container": true, "attrs": {"id": "axisalignislands"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Packing optimizations "], "extent": [5362, 5392]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Orientations"], "extent": [5392, 5407], "body": [{"type": "para", "indent": 4, "text": ["Try this many orientations of each island when trying to pack islands tighter. For example, the default ", {"type": "code", "text": ["4"]}, " tries each island at 0\u00b0, 90\u00b0, 180\u00b0, and 270\u00b0. Increasing this ", {"type": "em", "text": ["may"]}, " allow the algorithm to find a better packing, especially when you have some non-square islands, but will make packing slower."], "extent": [5431, 5742]}, {"type": "para", "indent": 4, "text": ["If you have fat and mostly convex polygons, there\u2019s little to achieve from rotating them in small increments. Elongated highly concave shapes on the other hand can benefit a lot."], "extent": [5742, 5926]}], "container": true, "attrs": {"id": "rotations"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Iterations"], "extent": [5926, 5938], "body": [{"type": "para", "indent": 4, "text": ["How many times the algorithm will try packing the islands together in different ways to try to find the most efficient packing. Increasing this ", {"type": "em", "text": ["may"]}, " allow the algorithm to find a better packing, but will make packing slower. Note that the first iteration sorts islands by area and so represents the best possible ", {"type": "q", "text": ["first guess"]}, ". Additional iterations use random sorting, so 2 iterations isn\u2019t necessarily ", {"type": "q", "text": ["twice as good"]}, " as 1, and you might need a lot more iterations to see any improvement over just ", {"type": "code", "text": ["1"]}, ". "], "extent": [5963, 6475]}], "container": true, "attrs": {"id": "iterations"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Random Seed"], "extent": [6475, 6488], "body": [{"type": "para", "indent": 4, "text": ["Iterations greater than ", {"type": "code", "text": ["1"]}, " use random sorting. This number seeds the random order generator. You can change it to get different permutations with the same number of iterations."], "extent": [6511, 6695]}], "container": true, "attrs": {"id": "randseed"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Advanced "], "extent": [6695, 6712]}, {"type": "para", "indent": 0, "text": ["Generally, you shouldn\u2019t need to change these values unless you're dealing with unusually detailed geometry. They may allow slightly finer placement of islands but the difference will probably be too small to matter."], "extent": [6712, 6931]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Frame Width"], "extent": [6931, 6944], "body": [{"type": "para", "indent": 4, "text": ["The packing algorithm is based on a rasterization of the islands.\n    This controls the resolution of the rasterized bitmap.\n    Increasing this allows finer placement of islands but is slower."], "extent": [6944, 7143]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Connectivity Tolerance"], "extent": [7143, 7167], "body": [{"type": "para", "indent": 4, "text": ["UV coordinates within this tolerance are considered to be at the same position and connected.\n    This is necessary because of the imprecision of floating-point math.\n    If islands come apart unexpectedly you can try increasing this slightly."], "extent": [7167, 7416]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Scale Error Tolerance"], "extent": [7416, 7439], "body": [{"type": "para", "indent": 4, "text": ["When doing a binary search of sizes to find the largest island size that still fits in available space, the algorithm will stop when the difference between the size that doesn\u2019t fit and the size that does fit is within this tolerance.\n    Decreasing this allows finer placement of island but is slower."], "extent": [7439, 7748]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [7748, 7757], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/uvproject", "type": "link", "text": "", "fullpath": "/nodes/sop/uvproject.html"}], "extent": [7757, 7781]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/uvquickshade", "type": "link", "text": "", "fullpath": "/nodes/sop/uvquickshade.html"}], "extent": [7781, 7807]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/texture", "type": "link", "text": "", "fullpath": "/nodes/sop/texture.html"}], "extent": [7807, 7828]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/uvpelt", "type": "link", "text": "", "fullpath": "/nodes/sop/uvpelt.html"}], "extent": [7828, 7848]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/uvunwrap", "type": "link", "text": "", "fullpath": "/nodes/sop/uvunwrap.html"}], "extent": [7848, 7871]}], "container": true}], "text": "Related"}], "title": ["UV Layout"], "summary": ["Tries to pack UV islands efficiently into a limited area."]}